<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[感谢大家的关注]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E5%85%B3%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[感谢大家的关注，尤其是同学们的关注，下个月起博客恢复更新。]]></content>
      <categories>
        <category>生活杂感</category>
      </categories>
      <tags>
        <tag>随笔录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索网络连接 1]]></title>
    <url>%2F2017%2F10%2F01%2F%E6%8E%A2%E7%B4%A2%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%201%2F</url>
    <content type="text"><![CDATA[从应用程序收到委托后，协议栈通过TCP协议收发数据的操作可以分为4个阶段。首先是创建套接字,然后是连接服务器，然后是收发数据，最后断开连接并删除套接字。本文仅涉及粗略理论，不谈实际操作。 协议栈是什么高端名词？说白了就是一个操作系统中的一个软件，这个软件的作用就是网络控制，但中间的数据包传送过程光靠软件肯定不行的，还需要硬件，那就是网卡，孤零零的网卡也不管用，加上个网卡的驱动软件就好了。嗯，粗略的大致这样。下面一层一层剥开4个阶段。 创建套接字可能又要疑惑套接字是个什么玩意了，但联系到我们学过的语言如C，java等，创建一词一般用于开辟一块内存区域来存放变量或者信息的，套接字就可以说是这块信息内容的中文名字了，那信息内容又具体是什么呢，一个通信操作的控制信息，信息里面藏着有通信对象的ip地址，端口号，通信操作的进行状态等。其实到这里你可以知道，创建套接字是为了建立一个管道，管道的一边是连接端口1，另一边是连接端口2，端口12都是套接字，用来存储连接及连接过程的信息。在windows上可以通过netstat来显示套接字信息。然而，这管道又怎样来真实化呢？这是下个阶段的内容。 连接服务器这步操作至关重要，牵连的东西很多，这里长话短说。 连接是通信双方（也就是上一段说的端口12）交换控制信息。创建套接字时实际上控制信息并无着落，双方收录这些必要的信息，分配收发数据的缓冲区的内存空间。然而这些必要的信息又是及其重要的，必须给他的形式及要求分配规则，这规则称之为TCP协议。可是这些必要的信息不止分布在协议的头部信息里，还分布在套接字里，毕竟要分工合作。说白了，这一步包含创建控制信息的头部（包含TCP头部），委托网卡IP模块通过IP协议发送控制信息及接受对方控制信息，这样，套接字的两端（通过端口号）就连接了起来。 收发数据其实在连接服务器过程中，已经开始收发数据了，不过这个数据信息仅包含控制信息的头部信息，不包含http请求的内容，在创建套接字的同时也创建了准备收发数据的缓冲区，因为收发的数据的信息到了这个时候肯定都是01代码了，01代码充满了缓冲区或者01代码要结束了就准备发送工作，让IP模块发送出去，另一端收到数据信息，记录这段01代码处于总信息的位置信息等，再把收到信息的信号发送回去，发送端收到信号继续发送，一系列这样的过程，就把http请求的内容给发送光了。 断开连接和删除套接字http的请求每秒都在发生，每个应用程序都有这样的那样的请求，占用了大量的信号资源，故而在收发数据完成后，会延迟一段时间（几分钟）就会把这样的连接关掉，具体的就是发送断开连接信号，删除套接字，空出资源（服务端和客户端）为下一个连接做准备。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒个气泡]]></title>
    <url>%2F2017%2F08%2F20%2F%E5%86%92%E4%B8%AA%E6%B0%94%E6%B3%A1%2F</url>
    <content type="text"><![CDATA[已经有接近三个月没有动我的博客了，开始写博客的时候是为了一部分好玩新鲜，一部分想证明我会写博客了，在这样的新鲜感过后，就没有了动力继续写我的技术博客。在学习和生活中，也时常有不如意之事，老大不小，该谋谋前程了。 今暑假到了车尾，之中有大把时间，不得自由，之后有很少闲暇，而得自由。时间不能定义自由，充实才靠近自由。]]></content>
      <categories>
        <category>生活杂感</category>
      </categories>
      <tags>
        <tag>随笔录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易成绩管理]]></title>
    <url>%2F2017%2F04%2F23%2F%E7%AE%80%E6%98%93%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[尝试使用了两个方案来实现这个成绩管理，一个是链表形式的，一个是应用模板vector的，相比而言，链表写得比较粗糙，因为当时还没学习数据结构，自学的链表。而vector模板就用得的心顺手了。然而这一段学习过程却对我之后的数据结构学习有很大帮助，另外学过了离散数学，学习数据结构课程就很不费劲。 这个成绩管理系统包含10个功能模块，其中有新建，浏览，保存，打开，增加，删除，修改，查询，插入和排序。两周方案的运行界面都如下： 链表形式h文件1234567891011121314151617181920212223242526272829303132333435363738394041424344#pragma once#ifndef GRADE_H#define GRADE_H#include&lt;string&gt;using namespace std;class Node&#123; string stu_id; string name; int math; int english; double average; Node *link;public: Node(); ~Node(); Node(const Node &amp;n); void operator=(const Node &amp;n); friend class grade; friend void swap(Node &amp;n1, Node &amp;n2);&#125;;class grade&#123;protected: Node *head; int amount;public: grade(); void create(); void view(); void add(); void del(); void change(); void inquire(); void read(); void write(); void insert(); void sort();&#125;;void init(grade &amp;g);#endif cpp文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474#include"grade.h"#include&lt;fstream&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include"grade.h"using namespace std;Node::Node()&#123;&#125;Node::~Node()&#123; if (link != NULL) &#123; link = NULL; &#125;&#125;Node::Node(const Node &amp;n)&#123; this-&gt;stu_id = n.stu_id; this-&gt;name = n.name; this-&gt;math = n.math; this-&gt;english = n.english; this-&gt;average = n.average; this-&gt;link = n.link;&#125;void Node::operator=(const Node &amp;n)&#123; this-&gt;stu_id = n.stu_id; this-&gt;name = n.name; this-&gt;math = n.math; this-&gt;english = n.english; this-&gt;average = n.average;&#125;grade::grade()&#123; head = NULL; amount = 0;&#125;void grade::create()&#123; amount = 0; int n; cout &lt;&lt; "请输入需要录入的学生数量：" &lt;&lt; endl; cin &gt;&gt; n; Node *p, *q; p = new Node; int i = 1; cout &lt;&lt; "以学号，姓名，数学成绩，英语成绩顺序输入" &lt;&lt; endl; cout &lt;&lt; "请输入第 " &lt;&lt; i &lt;&lt; " 个记录" &lt;&lt; endl; cin &gt;&gt; p-&gt;stu_id &gt;&gt; p-&gt;name &gt;&gt; p-&gt;math &gt;&gt; p-&gt;english; p-&gt;average = (p-&gt;math + p-&gt;english) / 2.0; amount++; cin.clear(); head = p; q = p; while (i &lt; n) &#123; i++; p = new Node; cout &lt;&lt; "请输入第 " &lt;&lt; i &lt;&lt; " 个记录" &lt;&lt; endl; cin &gt;&gt; p-&gt;stu_id &gt;&gt; p-&gt;name &gt;&gt; p-&gt;math &gt;&gt; p-&gt;english; p-&gt;average = (p-&gt;math + p-&gt;english) / 2.0; amount++; cin.clear(); q-&gt;link = p; q = p; &#125; q-&gt;link = NULL;&#125;void grade::view()&#123; if (head == NULL) &#123; cout &lt;&lt; "没有记录!" &lt;&lt; endl; return; &#125; Node *p = head; cout &lt;&lt; "\t学号\t姓名\t数学\t英语\t平均" &lt;&lt; endl; while (p) &#123; cout &lt;&lt; '\t' &lt;&lt; p-&gt;stu_id &lt;&lt; '\t' &lt;&lt; p-&gt;name &lt;&lt; '\t' &lt;&lt; p-&gt;math &lt;&lt; '\t' &lt;&lt; p-&gt;english &lt;&lt; '\t' &lt;&lt; p-&gt;average &lt;&lt; endl; p = p-&gt;link; &#125; cout &lt;&lt; "总人数： " &lt;&lt; amount &lt;&lt; endl;&#125;void grade::add()&#123; if (head == NULL) &#123; create(); return; &#125; int n; cout &lt;&lt; "请输入需要增添的学生数量：" &lt;&lt; endl; cin &gt;&gt; n; Node *q = head; while (q-&gt;link) q = q-&gt;link; cout &lt;&lt; "以学号，姓名，数学成绩，英语成绩顺序输入" &lt;&lt; endl; int i = 0; while (i&lt;n) &#123; i++; Node *p = new Node; cout &lt;&lt; "请输入第 " &lt;&lt; i &lt;&lt; " 个需要添加的记录" &lt;&lt; endl; cin &gt;&gt; p-&gt;stu_id &gt;&gt; p-&gt;name &gt;&gt; p-&gt;math &gt;&gt; p-&gt;english; p-&gt;average = (p-&gt;math + p-&gt;english) / 2.0; amount++; q-&gt;link = p; q = p; &#125; q-&gt;link = NULL; return;&#125;void grade::del()&#123; if (head == NULL) &#123; cout &lt;&lt; "\t没有记录！" &lt;&lt; endl; return; &#125; string stu_id; cout &lt;&lt; "请输入需要删除的学生学号：" &lt;&lt; endl; cin &gt;&gt; stu_id; int flag = 0; Node *p, *q; p = head; while (!stu_id.compare(p-&gt;stu_id)) &#123; if (p-&gt;link == NULL) &#123; delete p; amount--; p = NULL; head = NULL; cout &lt;&lt; "记录已全部删除！" &lt;&lt; endl; return; &#125; q = p-&gt;link; delete p; p = q; flag = 1; amount--; &#125; head = p; if (head-&gt;link == NULL) &#123; return; &#125; p = head; while (p-&gt;link != NULL) &#123; q = p-&gt;link; if (!q-&gt;stu_id.compare(stu_id)) &#123; if (q-&gt;link == NULL) &#123; delete q; amount--; p-&gt;link = NULL; return; &#125; p-&gt;link = q-&gt;link; delete q; flag = 1; amount--; &#125; p = p-&gt;link; &#125; if (flag == 0) &#123; cout &lt;&lt; "没有你删除的记录！" &lt;&lt; endl; &#125; return;&#125;void grade::change()&#123; if (head == NULL) &#123; cout &lt;&lt; "\t没有记录！" &lt;&lt; endl; return; &#125; string stu_id; cout &lt;&lt; "请输入需要修改的学生学号：" &lt;&lt; endl; cin &gt;&gt; stu_id; Node *p = head; while (p) &#123; if (!stu_id.compare(p-&gt;stu_id)) &#123; string str; cout &lt;&lt; "请输入要改动的字段所对应编号。1,学号； 2,姓名； 3,数学成绩； 4,英语成绩；多选以逗号隔开" &lt;&lt; endl; cin &gt;&gt; str; char re; for (unsigned int i = 0; i &lt; str.size(); i++) &#123; re = str[i]; if (re == '1') &#123; cout &lt;&lt; "请输入新的学号" &lt;&lt; endl; cin &gt;&gt; p-&gt;stu_id; continue; &#125; if (re == '2') &#123; cout &lt;&lt; "请输入新的姓名" &lt;&lt; endl; cin &gt;&gt; p-&gt;name; continue; &#125; if (re == '3') &#123; cout &lt;&lt; "请输入新的数学成绩" &lt;&lt; endl; cin &gt;&gt; p-&gt;math; continue; &#125; if (re == '4') &#123; cout &lt;&lt; "请输入新的英语成绩" &lt;&lt; endl; cin &gt;&gt; p-&gt;english; continue; &#125; &#125; p-&gt;average = (p-&gt;math + p-&gt;english) / 2.0; cout &lt;&lt; "该学生新的记录如下" &lt;&lt; endl; cout &lt;&lt; "\t学号\t姓名\t数学\t英语" &lt;&lt; endl; cout &lt;&lt; '\t' &lt;&lt; p-&gt;stu_id &lt;&lt; '\t' &lt;&lt; p-&gt;name &lt;&lt; '\t' &lt;&lt; p-&gt;math &lt;&lt; '\t' &lt;&lt; p-&gt;english &lt;&lt; p-&gt;average &lt;&lt; endl; break; &#125; p = p-&gt;link; &#125;&#125;void grade::inquire()&#123; if (head == NULL) &#123; cout &lt;&lt; "\t没有记录！" &lt;&lt; endl; return; &#125; string stu_id; cout &lt;&lt; "请输入需要查询的学生学号：" &lt;&lt; endl; cin &gt;&gt; stu_id; Node *p = head; int flag = 0; while (p) &#123; if (!stu_id.compare(p-&gt;stu_id)) &#123; if (flag == 0) &#123; cout &lt;&lt; "\t学号\t姓名\t数学\t英语" &lt;&lt; endl; &#125; cout &lt;&lt; '\t' &lt;&lt; p-&gt;stu_id &lt;&lt; '\t' &lt;&lt; p-&gt;name &lt;&lt; '\t' &lt;&lt; p-&gt;math &lt;&lt; '\t' &lt;&lt; p-&gt;english &lt;&lt; endl; flag = 1; &#125; p = p-&gt;link; &#125; if (flag == 0) &#123; cout &lt;&lt; "\t没有找到该学生！" &lt;&lt; endl; &#125;&#125;void grade::read()&#123; string filename; cout &lt;&lt; "请输入需要有效的文件名（可指定路径，必须包含后缀名）" &lt;&lt; endl; cin &gt;&gt; filename; ifstream ins; ins.open(filename, ios::binary); ins.seekg(0, ios::end); long length = long(ins.tellg()); ins.seekg(0, ios::beg); Node *p, *q; p = new Node; ins.read((char*)p, sizeof(Node)); amount++; if (head == NULL) &#123; cout &lt;&lt; "\t正在重新读取..." &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "\t正在读取数据..." &lt;&lt; endl; &#125; head = p; q = p; while (ins.tellg() &lt; length) &#123; p = new Node; ins.read((char*)p, sizeof(Node)); p-&gt;average = (p-&gt;math + p-&gt;english) / 2.0; q-&gt;link = p; q = p; amount++; &#125; q-&gt;link = NULL; ins.close(); view();&#125;void grade::write()&#123; string filename; cout &lt;&lt; "请输入需要有效的文件名（可指定路径，必须包含后缀名）" &lt;&lt; endl; cin &gt;&gt; filename; ofstream ous; ous.open(filename, ios::binary); if (head == NULL) &#123; cout &lt;&lt; "\t没有记录！" &lt;&lt; endl; return; &#125; cout &lt;&lt; "\t正在写入数据" &lt;&lt; endl; Node *p = head; while (p) &#123; ous.write((char*)p, sizeof(Node)); p = p-&gt;link; &#125; ous.close();&#125;void grade::sort()&#123; if (head == NULL) &#123; cout &lt;&lt; "无数据！" &lt;&lt; endl; &#125; if (head-&gt;link == NULL) &#123; return; &#125; Node *p, *q; p = head; while (p) &#123; q = p-&gt;link; while (q) &#123; if (p-&gt;average &gt;= q-&gt;average) &#123; swap(*p, *q); &#125; q = q-&gt;link; &#125; p = p-&gt;link; &#125; view();&#125;void grade::insert()&#123; char c; int flag = 0; if (head == NULL) &#123; cout &lt;&lt; "没有记录！\n接下来为你创建记录" &lt;&lt; endl; create(); cout &lt;&lt; "创建完毕，是否继续插入？输入1代表是，否则退出插入。" &lt;&lt; endl; cin &gt;&gt; c; if (c == '1') &#123;&#125; else &#123; return; &#125; &#125; cout &lt;&lt; "是否需要在第一个记录之前插入？输入1代表是，否则跳过" &lt;&lt; endl; cin &gt;&gt; c; Node *p, *q; p = head; Node *a = new Node; if (c == '1') &#123; cout &lt;&lt; "请输入需要插入的学生记录,按学号,姓名,数学成绩,英语成绩输入" &lt;&lt; endl; cin &gt;&gt; a-&gt;stu_id &gt;&gt; a-&gt;name &gt;&gt; a-&gt;math &gt;&gt; a-&gt;english; a-&gt;average = (a-&gt;math + a-&gt;english) / 2.0; a-&gt;link = p; head = a; flag = 1; cout &lt;&lt; "插入完成！" &lt;&lt; endl; return; &#125; string stu_id; cout &lt;&lt; "请输入学生学号，然后在该学生后面插入" &lt;&lt; endl; cin &gt;&gt; stu_id; cout &lt;&lt; "请输入需要插入的学生记录,按学号,姓名,数学成绩,英语成绩输入" &lt;&lt; endl; cin &gt;&gt; a-&gt;stu_id &gt;&gt; a-&gt;name &gt;&gt; a-&gt;math &gt;&gt; a-&gt;english; a-&gt;average = (a-&gt;math + a-&gt;english) / 2.0; while (p) &#123; if (p-&gt;link == NULL&amp;&amp;!stu_id.compare(p-&gt;stu_id)) &#123; p-&gt;link = a; a-&gt;link = NULL; flag = 1; return; &#125; q = p-&gt;link; if (!stu_id.compare(p-&gt;stu_id)) &#123; p-&gt;link = a; a-&gt;link = q; cout &lt;&lt; "插入完成！" &lt;&lt; endl; flag = 1; return; &#125; p = p-&gt;link; &#125; if (flag == 0) &#123; cout &lt;&lt; "找不到该学生学号！" &lt;&lt; endl; &#125;&#125;void swap(Node &amp;n1, Node &amp;n2)&#123; Node temp = n1; n1 = n2; n2 = temp;&#125;void init(grade &amp;g)&#123; char key; cout &lt;&lt; "----------------------------------------------" &lt;&lt; endl; cout &lt;&lt; " 欢迎进入学生信息管理系统 " &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; " 请输入编号进行相应的操作 " &lt;&lt; endl; cout &lt;&lt; "----------------------------------------------" &lt;&lt; endl; while (1) &#123; cout &lt;&lt; "**********************************************" &lt;&lt; endl; cout &lt;&lt; "\t1,新建\t2,浏览\t3,保存并退出\t4,打开\n\n\t5,增加\t6,删除\t7,修改\t8,查询\n\n\t9,排序\t0,插入" &lt;&lt; endl; cout &lt;&lt; "**********************************************" &lt;&lt; endl; cin &gt;&gt; key; cin.clear(); switch (key) &#123; case '0': g.insert(); break; case '1': g.create(); break; case '2': g.view(); break; case '3': g.write(); return; case '4': g.read(); break; case '5': g.add(); break; case '6': g.del(); break; case '7': g.change(); break; case '8': g.inquire(); break; case '9': g.sort(); break; default: cout &lt;&lt; "无效输入，请重新输入！" &lt;&lt; endl; &#125; &#125;&#125; vector应用h文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef VECTOR#define VECTOR#include&lt;vector&gt;using namespace std;class student&#123; char stu_id[20]; char name[10]; char phone_number[15]; char address[20]; char sex[3]; short age; float point_math; float point_english; float point_program; double average;public: static void print_field(); void input(); void print(); friend bool operator==(const student &amp;,const student &amp;); friend class students;&#125;;class students&#123; vector&lt;student&gt; mark;public: void create(); void view(); void drop(); void write(); void read(); void insert(); void add(); void del(); void update(); void inquire(); void sort();&#125;;void init(students &amp;);#endif cpp文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314#include"student.h"#ifndef VECTOR#include&lt;vector&gt;using namespace std;#endif#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;string&gt;void student::print_field()&#123; cout&lt;&lt;setw(14)&lt;&lt;" 学号 " &lt;&lt;setw(8)&lt;&lt;" 姓名 " &lt;&lt;setw(4)&lt;&lt;"性别" &lt;&lt;setw(4)&lt;&lt;"年龄" &lt;&lt;setw(14)&lt;&lt;"电话" &lt;&lt;setw(14)&lt;&lt;"地址" &lt;&lt;setw(6)&lt;&lt;" 数学 " &lt;&lt;setw(6)&lt;&lt;" 英语 " &lt;&lt;setw(6)&lt;&lt;" 程式 " &lt;&lt;setw(10)&lt;&lt;" 平均成绩 " &lt;&lt;endl;&#125;void student::input()&#123; cin &gt;&gt; this-&gt;stu_id &gt;&gt; this-&gt;name &gt;&gt; this-&gt;sex &gt;&gt; this-&gt;age &gt;&gt; this-&gt;phone_number &gt;&gt; this-&gt;address &gt;&gt; this-&gt;point_math &gt;&gt; this-&gt;point_english &gt;&gt; this-&gt;point_program; this-&gt;average = (this-&gt;point_math + this-&gt;point_english + this-&gt;point_program)/3.0;&#125;void student::print()&#123; cout&lt;&lt;setw(14)&lt;&lt;setiosflags(ios::right)&lt;&lt;this-&gt;stu_id &lt;&lt;setw(8)&lt;&lt;setiosflags(ios::left)&lt;&lt;this-&gt;name &lt;&lt;setw(4)&lt;&lt;setiosflags(ios::left)&lt;&lt;this-&gt;sex &lt;&lt;setw(4)&lt;&lt;setiosflags(ios::right)&lt;&lt;this-&gt;age &lt;&lt;setw(14)&lt;&lt;setiosflags(ios::right)&lt;&lt;this-&gt;phone_number &lt;&lt;setw(14)&lt;&lt;setiosflags(ios::left)&lt;&lt;this-&gt;address &lt;&lt;setw(6)&lt;&lt;setiosflags(ios::right)&lt;&lt;this-&gt;point_math &lt;&lt;setw(6)&lt;&lt;setiosflags(ios::right)&lt;&lt;this-&gt;point_english &lt;&lt;setw(6)&lt;&lt;setiosflags(ios::right)&lt;&lt;this-&gt;point_program &lt;&lt;setw(10)&lt;&lt;setiosflags(ios::right)&lt;&lt;this-&gt;average &lt;&lt;endl;&#125;bool operator==(const student &amp;s1,const student &amp;s2)&#123; if(s1.stu_id == s2.stu_id) &#123; return true; &#125; else &#123; return false; &#125;&#125;void students::create()&#123; int num = 0; int i = 0; student s; cout &lt;&lt; "请输入学生数量： "; cin &gt;&gt; num; cout &lt;&lt; "请以以下顺序输入信息(共9个)，以空格或回车隔开" &lt;&lt; endl; cout &lt;&lt; "学号， 姓名， 性别， 年龄， 电话， 地址， 数学分， 英语分， 程式分" &lt;&lt;endl; while(i &lt; num) &#123; cout &lt;&lt; "请输入第 " &lt;&lt; (i+1) &lt;&lt; "个学生信息：" &lt;&lt; endl; s.input(); mark.push_back(s); i++; &#125; cout &lt;&lt; "输入完毕，成功创建 " &lt;&lt; num &lt;&lt;"个学生信息记录！" &lt;&lt; endl;&#125;void students::view()&#123; student::print_field(); for(auto it = mark.begin(); it != mark.end(); it++) &#123; it-&gt;print(); &#125;&#125;void students::drop()&#123; mark.clear();&#125;void students::write()&#123; string filename; cout&lt;&lt;"请输入需要有效的文件名（可指定路径，必须包含后缀名）"&lt;&lt;endl; cin &gt;&gt; filename; ofstream ous; ous.open(filename,ios::binary); for(auto it = mark.begin(); it!=mark.end(); ++it) &#123; ous.write((char*)&amp;(*it),sizeof(student)); &#125; ous.close(); cout&lt;&lt;"保存成功!"&lt;&lt;endl;&#125;void students::read()&#123; string filename; cout&lt;&lt;"请输入需要有效的文件名（可指定路径，必须包含后缀名）"&lt;&lt;endl; cin &gt;&gt; filename; ifstream ins; ins.open(filename,ios::binary); ins.seekg(0,ios::end); long len = ins.tellg(); ins.seekg(0,ios::beg); student s; mark.clear(); while(long(ins.tellg()) != len) &#123; ins.read((char*)&amp;s,sizeof(student)); mark.push_back(s); &#125; ins.close(); cout&lt;&lt;"打开成功，文件包含 "&lt;&lt;mark.size()&lt;&lt;" 个学生信息记录！";&#125;void students::insert()&#123; int i = 0; student s; cout &lt;&lt; "请输入要插入的位置： "; cin &gt;&gt; i; while(i&gt;(mark.size()+1)||i &lt;= 0) &#123; cout &lt;&lt; "输入位置不合法，请重新输入！" &lt;&lt; endl; cin &gt;&gt; i; &#125; auto it = mark.begin() + (i-1); cout &lt;&lt; "请以以下顺序输入信息(共9个)，以空格或回车隔开" &lt;&lt; endl; cout &lt;&lt; "学号， 姓名， 性别， 年龄， 电话， 地址， 数学分， 英语分， 程式分" &lt;&lt;endl; s.input(); mark.insert(it,s); cout &lt;&lt; "插入成功！" &lt;&lt;endl;&#125;void students::add()&#123; int num = 0; int i = 0; student s; cout &lt;&lt; "请输入增加的学生数量： "; cin &gt;&gt; num; cout &lt;&lt; "请以以下顺序输入信息(共9个)，以空格或回车隔开" &lt;&lt; endl; cout &lt;&lt; "学号， 姓名， 性别， 年龄， 电话， 地址， 数学分， 英语分， 程式分" &lt;&lt;endl; while(i &lt; num) &#123; cout &lt;&lt; "请输入第 " &lt;&lt; (i+1) &lt;&lt; "个学生信息：" &lt;&lt; endl; s.input(); mark.push_back(s); i++; &#125; cout &lt;&lt; "输入完毕，成功增加 " &lt;&lt; num &lt;&lt;"个学生信息记录！" &lt;&lt; endl;&#125;void students::del()&#123; char key[20]; cout &lt;&lt; "请输入要删除的学生学号！" &lt;&lt; endl; cin &gt;&gt; key; for(auto it = mark.begin(); it != mark.end(); it++) &#123; if(!strcmp(key,it-&gt;stu_id)) &#123; mark.erase(it); cout &lt;&lt; "成功删除！" &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; "未找到该学号，删除失败！" &lt;&lt; endl;&#125;void students::update()&#123; char key[20]; cout &lt;&lt; "请输入要更新的学生学号： "; cin &gt;&gt; key; for(auto it = mark.begin(); it != mark.end(); it++) &#123; if(!strcmp(key,it-&gt;stu_id)) &#123; char str[20]; char c; cout &lt;&lt; "请输入需更新的项，多选以逗号隔开" &lt;&lt; endl; cout &lt;&lt; "1,学号，2,姓名，3,性别，4,年龄，5,电话，6,地址，7,数学分，8,英语分，9,程式分，0,全部" &lt;&lt;endl; cin &gt;&gt; str; for(int i = 0; i &lt; strlen(str); i++) &#123; c = str[i]; switch(c) &#123; case '1': cout &lt;&lt; "请输入学号： "; cin&gt;&gt;it-&gt;stu_id; break; case '2': cout &lt;&lt; "请输入姓名： "; cin&gt;&gt;it-&gt;name; break; case '3': cout &lt;&lt; "请输入性别： "; cin&gt;&gt;it-&gt;sex; break; case '4': cout &lt;&lt; "请输入年龄： "; cin&gt;&gt;it-&gt;age; break; case '5': cout &lt;&lt; "请输入电话： "; cin&gt;&gt;it-&gt;phone_number; break; case '6': cout &lt;&lt; "请输入地址： "; cin&gt;&gt;it-&gt;address; break; case '7': cout &lt;&lt; "请输入数学成绩： "; cin&gt;&gt;it-&gt;point_math; break; case '8': cout &lt;&lt; "请输入英语成绩： "; cin&gt;&gt;it-&gt;point_english; break; case '9': cout &lt;&lt; "请输入程式成绩： "; cin&gt;&gt;it-&gt;point_program; break; case '0': cout &lt;&lt; "请以以下顺序输入更新信息(共9个)，以空格或回车隔开" &lt;&lt; endl; cout &lt;&lt; "学号， 姓名， 性别， 年龄， 电话， 地址， 数学分， 英语分， 程式分" &lt;&lt;endl; it-&gt;input(); break; &#125; cout &lt;&lt; "更新成功！" &lt;&lt; endl; &#125; return; &#125; &#125; cout &lt;&lt; "未找到该学号，更新失败！" &lt;&lt; endl;&#125;void students::inquire()&#123; char key[20]; cout &lt;&lt; "请输入要查询的学生学号： "; cin &gt;&gt; key; for(auto it = mark.begin(); it != mark.end(); it++) &#123; if(!strcmp(key,it-&gt;stu_id)) &#123; student::print_field(); it-&gt;print(); cout &lt;&lt; "查询成功！"; return; &#125; &#125; cout &lt;&lt; "未找到该学号，查询失败！" &lt;&lt; endl;&#125;void students::sort()&#123; student temp; for(auto it = mark.begin(); it &lt; mark.end(); it++) &#123; for(auto is = it+1; is != mark.end(); is++) &#123; if(it-&gt;average &gt; is-&gt;average) &#123; temp = (*it); (*it) = (*is); (*is) = temp; &#125; &#125; &#125; cout &lt;&lt; "根据平均成绩排序完成！" &lt;&lt; endl;&#125;void init(students &amp;s)&#123; char key; cout&lt;&lt;"----------------------------------------------"&lt;&lt;endl; cout&lt;&lt;" 欢迎进入学生信息管理系统 "&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;" 请输入编号进行相应的操作 "&lt;&lt;endl; cout&lt;&lt;"----------------------------------------------"&lt;&lt;endl; while(1) &#123; cout&lt;&lt;"**********************************************"&lt;&lt;endl; cout&lt;&lt;"\t1,新建\t2,浏览\t3,保存并退出\t4,打开\n\n\t5,增加\t6,删除\t7,修改\t8,查询\n\n\t9,排序\t0,插入"&lt;&lt;endl; cout&lt;&lt;"**********************************************"&lt;&lt;endl; cin&gt;&gt;key; switch(key) &#123; case '0': s.insert(); break; case '1': s.create();break; case '2': s.view();break; case '3': s.write();return; case '4': s.read();break; case '5': s.add();break; case '6': s.del();break; case '7': s.update();break; case '8': s.inquire();break; case '9': s.sort();break; default: cout&lt;&lt;"无效输入，请重新输入！"&lt;&lt;endl; &#125; &#125;&#125; 代码较长，目前我还不会弄代码折叠功能，现在也只能附上下载链接：成绩管理文件]]></content>
      <categories>
        <category>小代码</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>成绩管理</tag>
        <tag>链表应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归 全排列]]></title>
    <url>%2F2017%2F04%2F16%2F%E9%80%92%E5%BD%92-%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[递归是什么，递是深入，层层深入就要求着每一层具有相似的环境；归是回归，每一个回归都是对问题解的靠近。如何从深入质变为回归？遇到节点，再无深入，只可回避。 教课语言不好理解，那我说说我自己的浅知（其实来自网友的感想）。语言的递归，一堆字符，被大家所接受和公认，慢慢积累，越来越多的字符，就成为了一种语言，适用于一方土地上居住的人。字符创造出来，又可以由字符组成一个个词符，词语再组成一个个句子，句子再组成一个个段落，段落再组成一篇篇文章，文章再组成一本本书，书再组成一个个系列，体系。这个过程多么神奇，人创造出语言，语言本身又可以创造和表达出许许多多的内容，反过来帮助人类沟通和交流。这里有没有递归呢？说实话我表达不了，距领悟还有一段很远的距离。 上文有些软绵绵的，下面请看一个精彩的递归示例：全排列。 举个例子：abc的全排列。 思路：交换。当前下标1的元素不断与后面下标的元素进行交换，交换后下标加1，直到下标加到限定值即序列尾部。第一次交换，则有abc,bac,cba三种。第二次交换，主意当前下标1是往后推一到2了，则有abc -&gt; (abc,acb), bac -&gt; (bac,bca), cba -&gt;(cba,cab)六种，第三次交换当前下标3已经到底了，就回溯，先后输出 abc acb bac bca cba cab。就完成了问题的解决。代码：1234567891011121314151617181920212223242526272829303132333435bool isswap(char* ch, char a, char b)&#123;//判断是否要发生交换，自己琢磨为什么这样做能防止重复交换 for (int i = a; i &lt; b; i++) if (ch[i] == ch[b]) return false; return true;&#125;void swap(char &amp;a, char &amp;b)&#123;//交换函数 char t = a; a = b; b = t;&#125;int count = 0;void quanpailie(char* ch, int begin, int end)&#123; if (begin == end) &#123;//递归出口，即当前下标递增到序列尾 for (int i = 0; i &lt;= end; i++) cout &lt;&lt; ch[i]; cout &lt;&lt; endl; count++; &#125; else &#123;//不是出口，就一直交换下去，直到出口方息 for (int j = begin; j &lt;= end; j++) &#123; if (isswap(ch,begin,j)) &#123;//防止重复交换，针对序列中有重复元素而言 swap(ch[begin], ch[j]); quanpailie(ch, begin + 1, end); swap(ch[begin], ch[j]); &#125; &#125; &#125;&#125; 拿了abc的测试：123456789int main()&#123; cout &lt;&lt; "abc的全排列" &lt;&lt; endl; cout &lt;&lt; "==========" &lt;&lt; endl; char A[6] = &#123; 'a','b','c'&#125;; quanpailie(A, 0, 2); cout &lt;&lt; "==========" &lt;&lt; endl; cout &lt;&lt; "共" &lt;&lt; count &lt;&lt; "种排列方案。" &lt;&lt; endl;&#125; 结果是：12345678910abc的全排列==========abcacbbacbcacbacab==========共6种排列方案。 拿了abbc的测试：123456789int main()&#123; cout &lt;&lt; "abc的全排列" &lt;&lt; endl; cout &lt;&lt; "==========" &lt;&lt; endl; char A[6] = &#123; 'a','b','b','c'&#125;; quanpailie(A, 0, 3); cout &lt;&lt; "==========" &lt;&lt; endl; cout &lt;&lt; "共" &lt;&lt; count &lt;&lt; "种排列方案。" &lt;&lt; endl;&#125; 结果是：12345678910111213141516abc的全排列==========abbcabcbacbbbabcbacbbbacbbcabcbabcabcbbacbabcabb==========共12种排列方案。 嗯，结果和预期完全符合，即便有相同元素作怪也能有选择的回避重复排列。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归</tag>
        <tag>全排列算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础队列]]></title>
    <url>%2F2017%2F04%2F04%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈是操作受限的先进后出的表，队列和栈稍有相同的就是队列也是操作受限的，受限之处在于插入操作只能在队尾进行（后方高能不许插队），删除操作只能在队头进行（结完账赶紧走）。如果一直插入的话，很容易发现，一开始插入的被一点一点挤到队的前面去了，后面插入的就离队的尾部近一点，知道最后插入的直接在队尾；总结起来就是：先进先出，先到先得。这和我们日常生活中的很多排队现象是相同的，所以队列在数据结构中应用的很广泛，如消息响应机制等。 排好队呀队排好，谁要加队是傻吊。凡事都要讲道理，先来后到次序好。 前言由于插入和删除操作的位置分离，插入在队尾进行，俗称入队，删除在队头进行，人称出队。必然地由着这个性质推断出需要的两位成员：能表示队首和队尾的位置。队也是特殊的线性表，当然呢可以分成数组存储和链式存储，而且待会你还会看到，由于充分利用空间而出现的循环队列，而这是栈所不需要的。 数组队列定义数组用来标志位置的显然只有下标能担当，一个下标来表示队头，另一个下标来表示队尾。定义内容如下12345678typedef char classname;const int maxsize = 100;struct Queue&#123; classname data[maxsize]; int first; int last;&#125;; 基本操作初始化在一个清晨，杂货店前什么人也没有，但老板已经摆出了铺子。123456void init(SqQueue* &amp;Q)&#123; Q = new SqQueue; Q-&gt;first = -1; Q-&gt;last = -1;&#125; 用不合法下标-1表示队列初始的状态。 入队朝阳缓缓升起，杂货店前陆陆续续的来了人，公民们素质很高，都会有”先来后到“的礼貌。1234567bool insert(SqQueue* &amp;Q, classname c)&#123; if (Q-&gt;last == maxsize - 1) return false; Q-&gt;data[++Q-&gt;last] = c; return true;&#125; 咦，没位置了，我怎么排队。 出队后面的一个家伙指着前面的人说：前面买完东西的赶紧走，空出位置好排队。1234567bool del(SqQueue* &amp;Q, classname &amp;c)&#123; if (Q-&gt;first == Q-&gt;last) return false; c = Q-&gt;data[++Q-&gt;first]; return true;&#125; 有人才会有江湖，有踢人。 队首队尾第一和倒一的风采。12345678910111213bool firstQueue(SqQueue* Q, classname &amp;c)&#123; if (Q-&gt;first == Q-&gt;last) return false; c = Q-&gt;data[Q-&gt;first];&#125;bool lastQueue(SqQueue* Q, classname &amp;c)&#123; if (Q-&gt;first == Q-&gt;last) return false; c = Q-&gt;data[Q-&gt;last];&#125; 队满队空不能再排队了，或者根本没人在排队。123456789bool isFull(SqQueue* Q)&#123; return (Q-&gt;last == maxsize - 1)&#125;bool isEmpty(SqQueue* Q)&#123; return (Q-&gt;first == Q-&gt;last)&#125; 什么时候为满？队尾就是容纳量。什么时候为空？队尾和队头在一起。 建队删队建队的过程就是一个个元素入队的过程；删队就是直接删除那个空间。1234567891011void create(SqQueue* &amp;Q, classname a[], size_t n)&#123; init(Q); for (size_t i = 0; i &lt; n; i++) insert(Q, a[i]);&#125;void del(SqQueue* &amp;Q)&#123; delete Q;&#125; 循环数组队列说明从上文的数组队列看以看出，在不断的出队过程中，队首下标不断增加，而数组空间内从0到队首下标的哪一段空间确实是被抛弃和浪费了，如果队满了，那则是一种“假满”状态，因为数组空间还有未被利用的空间。出此考虑，我们设计一种方案，能完全的利用整片数组空间，也就是循环数组队列。它的思想是在队满的时候，将队满的下一个下标和数组空间0下标连接和过渡起来，好像数组成了一个环，没有最后的位置，只有最满的状态。队首和队尾不再有严格的先后关系，而是作为一种操作标记，因为坐成一圈的人没法像直队那样分出先后。总结上文，循环数组队列不是数组循环，而是在入队出队的操作上改进使之能够满足循环从而充分利用空间。那么，队列的定义依旧不变，变的是操作。 定义和数组队列一样12345678typedef char classname;const int maxsize = 100;struct Queue&#123; classname data[maxsize]; int first; int last;&#125;; 操作初始化这里的初始和数组队列的初始化要区别开来的一个问题是：能不能把first和last都初始化为-1的问题。假设如下情况，在不断插队的过程中last指针已经到了maxsize-1，依着循环，下一个应增加到maxsize%maxsize，即为0，而此时的first指针依旧是-1，这样就永远无法判断队满的状态了，若想判断成功，则first初始值应该是0。那么，再由于初始化时队一定是空的，故而last初始值要和first初始值一样同为0。如此，才可能有队满条件：（last+1）% maxsize == first; 才可能有队空条件：first == last。123456void init(SqQueue* &amp;Q)&#123; Q = new SqQueue; Q-&gt;first = 0; Q-&gt;last = 0;&#125; 进队稍有不同的是，last指针的移动方式是：last = (last + 1) % maxsize;12345678bool insert(SqQueue* &amp;Q, classname c)&#123; if ((Q-&gt;last + 1)%maxsize == Q-&gt;first ) return false; Q-&gt;last = (Q-&gt;last + 1) % maxsize; Q-&gt;data[Q-&gt;last] = c; return true;&#125; 出队同样和进队类似的方式，first指针移动方式是： first = (first + 1) % maxsize;12345678bool del(SqQueue* &amp;Q, classname &amp;c)&#123; if (Q-&gt;first == Q-&gt;last) return false; Q-&gt;first = (Q-&gt;first + 1) % maxsize; c = Q-&gt;data[Q-&gt;first]; return true;&#125; 队首队尾和数组队列同。12345678910111213bool firstQueue(SqQueue* Q, classname &amp;c)&#123; if (Q-&gt;first == Q-&gt;last) return false; c = Q-&gt;data[Q-&gt;first];&#125;bool lastQueue(SqQueue* Q, classname &amp;c)&#123; if (Q-&gt;first == Q-&gt;last) return false; c = Q-&gt;data[Q-&gt;last];&#125; 队满队空前文已明。123456789bool isFull(SqQueue* Q)&#123; return ((Q-&gt;last + 1) % maxsize == Q-&gt;first);&#125;bool isEmpty(SqQueue* Q)&#123; return (Q-&gt;first == Q-&gt;last);&#125; 建队和删队和数组队列一模一样。1234567891011void create(SqQueue* &amp;Q, classname a[], size_t n)&#123; init(Q); for (size_t i = 0; i &lt; n; i++) insert(Q, a[i]);&#125;void del(SqQueue* &amp;Q)&#123; delete Q;&#125; 链队定义和数组不同，链队由于在内存中随机寻找空间，不需要考虑空间利用的问题，这也就带来了方便的操作。然而，需要考虑的另一个问题是：队首和队空的位置如何表示？如果用头节点表示队首，尾节点表示队尾，不是不可以，是太狼狈了，每次要循环寻找队尾，是一种队时间的浪费。那么，可不可以想个办法，让队尾和队首可以轻易找到？或者队尾就在队首身边？一个可行的方案就是，制造一个同时含有指向队首和队尾的指针的特殊节点。而那些队中的节点还是和之前一样，一个数据域，一个指针域。123456789101112typedef char classname;struct Node&#123; classname data; NodeQueue* next;&#125;;struct NodeQueue //指向队首和队尾的特殊节点&#123; Node* first; Node* last;&#125;; 基本操作初始化新建NodeQueue，将NodeQueue的first和last指针都置空。123456void init(NodeQueue* &amp;Q)&#123; Q = new NodeQueue; Q-&gt;first = NULL; Q-&gt;last = NULL;&#125; 队空在NodeQueue的first指针为空的时候即是队空的时刻。1234bool isEmpty(NodeQueue* &amp;Q)&#123; return Q-&gt;first == NULL;&#125; 进队特殊情况是队为空的时候12345678910111213void insert(NodeQueue* &amp;Q, classname c)&#123; Node* p = new Node; p-&gt;data = c; p-&gt;next = NULL; if (Q-&gt;first == NULL) Q-&gt;first = Q-&gt;last = p; //若无队首，则该元素是队首和队尾 else &#123; Q-&gt;last-&gt;next = p; Q-&gt;last = p; &#125;&#125; 出队特殊情况是队首和队空相同123456789101112131415bool del(NodeQueue* &amp;Q, classname &amp;c)&#123; if (Q-&gt;first == NULL) return false; Node* p = Q-&gt;first; if (Q-&gt;first == Q-&gt;last) Q-&gt;first = Q-&gt;last = NULL; //仅有一个元素 else &#123; Q-&gt;first = Q-&gt;first-&gt;next; c = p-&gt;data; delete p; &#125; return true;&#125; 队首队尾没什么好说哦。123456789101112131415bool firstQueue(NodeQueue* Q, classname &amp;c)&#123; if (Q-&gt;first == NULL) return false; c = Q-&gt;first-&gt;data; return true;&#125;bool lastQueue(NodeQueue* Q, classname &amp;c)&#123; if (Q-&gt;first == NULL) return false; c = Q-&gt;last-&gt;data; return true;&#125; 建队和删队建队和以前的一样，一个个的插入。删队则是一个个的出队。12345678910111213void create(NodeQueue* &amp;Q, classname a[], size_t n)&#123; init(Q); for (size_t i = 0; i &lt; n; i++) insert(Q, a[i]);&#125;void destory(NodeQueue* &amp;Q)&#123; classname c; while (Q-&gt;first != NULL) del(Q, c);&#125; 总结至此已经结束了队列的基本讲解。回过头发现，这些操作都是基本单链表的基本操作。祝君好运。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构C++</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础栈]]></title>
    <url>%2F2017%2F03%2F30%2F%E5%9F%BA%E7%A1%80%E6%A0%88%2F</url>
    <content type="text"><![CDATA[说起来栈和队列是与线性表是分不开的，元素和元素之间仍是一种一对一的关系，用数学语言描述就是偏序关系，把元素按逻辑关系连接起来成线性结构。虽然也说是一种线性表，但要单独拿出来命名，必有其特殊作用，表现在： 操作受限，仅允许在栈的顶端进行操作，这区别于顺序表链表的任意位置都可以进行操作。 元素的组织形式是这样的，先进栈的元素后出栈，后进栈的元素先进栈，这个特点又使它有另一个称呼为先进后出表。 上面叙述中出现了进栈和出栈两个名词，进栈是把元素放进栈，出栈是从栈把元素取出。因为栈是一种特殊的线性表，故而存储方式肯定也是分为集体存储和随机储存，也就是所谓的数组栈和链栈。有了前面顺序表和链表的学习，只需明白栈是只能“动头头”的东西就好了。下面分别来说数组栈和链栈。我的语言可能有点偏怪，不喜勿入。 数组栈定义####为什么这样定义我们需要来怎样定义栈才能符合刚才提出的要求呢，简单分析一下。数组栈，顾名思义，元素存在数组空间里，so需要一个数组data[maxsize]；再来和顺序表比较一下，确认是否需要length呢？顺序表要length是因为操作上的需要，如增删改查里面的条件判断，创建一定长度的数组，长度的更改频繁等一系列需求，而对于栈，长度并不是我们关心的主体内容，我们关心的是栈顶是什么元素，是否为NULL，然后栈是否满了，这些均和栈的长度无太大关联，真是需要长度的话可以加一个求栈的长度的函数，现在的问题是，我们关心的栈顶用什么来表示比较合适，栈顶是当前最后入栈的元素，元素是不确定的，元素的位置（下标）却是确定的：length-1，原来到这你会发现好像是又转回去成length了，对此我表示无奈，我只想说length-1太不协调，我们用一个能表示栈顶状态的名字来代替它，嗯，就这么做，这个名字叫做top，有没有瞬间高大上的感觉？同时也要注意到top是一个位置即下标，而length是描述长度，这就是含义的差别了。到此，栈的定义也就明显了，包含data[maxsize]和top。 ####定义结果1234567typedef char classname;const int maxsize = 1000; //以上是预定义内容struct Stack &#123; classname data[maxsize]; //数组 int top; //栈顶&#125;; 将top定义为int类型而不是size_t是因为想用top = -1这个不合法下标值来表示一个栈空的状态。 基本操作有之前学习的顺序表的基本操作做基础，基本的东西就不能再简单了。 初始化让开，我要开辟一片荒芜的山洞，然而我人力有限，暂时只能是一个笔直的山洞，有终点的山洞。 洞有小口，仿佛若有光。从口入，初极狭，才通人。12345void init(Stack* &amp;stack)&#123; stack = new Stack; stack-&gt;top = -1;&#125; 进栈一个强盗进入了我挖的山洞并且到达终点。然后我立马在他身后立起一堵墙。好玩吗，哈哈哈1234567891011bool push(Stack* &amp;stack, classname c)&#123; if (stack-&gt;top &lt; maxsize - 1) &#123; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = c; return true; &#125; else return false;&#125; 让人进来总得看看还有没有位置没，你说呢？有位置的话，他进来后我就在在他身后上一睹墙~别说我坏 出栈最后进来的强盗在想，这山洞的主人不是什么好鸟，坑，不过我也不是吃素的，我的身后只有一堵墙，我要出去只要打破这一堵墙就好了，后面的兄弟祝你们好运，嘿嘿1234567891011bool pop(Stack* &amp;stack, classname &amp;c)&#123; if (stack-&gt;top &gt; -1) &#123; c = stack-&gt;data[stack-&gt;top]; stack-&gt;top--; return true; &#125; else return false;&#125; 若是山洞里面没有强盗了，也就没有所谓的”打掉身后的墙”的必要了。 取顶有些时候我想知道进来的强盗们到底谁在打墙，在最后一个强盗位置使出隐身术，嘿嘿，原来是西门庆，OK，得知你是谁了，我把你身后的墙变成铜墙铁壁，哈哈哈。12345678910bool topc(Stack* stack, classname &amp;c)&#123; if (stack-&gt;top &gt; -1) &#123; c = stack-&gt;data[stack-&gt;top]; return true; &#125; else return false;&#125; 没有强盗在内，我才不使出隐身术呢。 空与满是有没有强盗和还能不能关进强盗的问题。123456789101112131415bool isEmpty(Stack* stack)&#123; if (stack-&gt;top &gt; -1) return true; else return false;&#125;bool isFull(Stack* stack)&#123; if (stack-&gt;top == maxsize - 1) return true; else return false;&#125; 建栈没有关着强盗的山洞不是好山洞，于是我去找了一堆捆仙绳去抓坏人了，先抓到的先关进山洞。123456void create(Stack* &amp;stack, classname a[], size_t length)&#123; init(stack); for (int i = 0; i &lt; length; i++) push(stack, a[i]);&#125; 英俊的我，在关强盗之前先帮你们清理一下山洞，你们关着也舒服。 毁栈无聊之下，我毁了整个山洞，当然强盗们也就灰飞烟灭了，所以毁灭从来都是一个神的禁忌。1234void destory(Stack* &amp;stack)&#123; delete stack;&#125; 对不起，强盗们，你们的生命重归于混沌。 链栈定义和数组的思维相同，有区别的是链栈只需考虑栈是否空了，栈满不满的问题不关系，因为这是链的特质啊。数组用下标来表示一个特殊的栈顶位置，那么链呢，哪个位置特殊？当然是原生的头节点啊。下面看看怎么定义哦。123456typedef char classname;struct NodeStack&#123; classname data; NodeStack* next;&#125;; 完全和链的节点一样嘛，不过要注意到我现在只可以动动头节点了，在栈里面头节点不好听，把头节点的下一个改名为栈顶。下面继续。 基本操作初始化这和链表的初始化并没有什么不同。12345void init(NodeStack* &amp;stack)&#123; stack = new NodeStack; stack-&gt;next = NULL;&#125; 进栈还记得链表的插入操作吗？进栈就是在栈顶之前插入一个节点啊，使这个节点成为新的栈顶。12345678bool push(NodeStack* &amp;stack, classname c)&#123; NodeStack * p = new NodeStack; p-&gt;data = c; p-&gt;next = stack-&gt;next; stack-&gt;next = p; return true;&#125; 和顺序栈相比少了条件的判断。 出栈不瞒你说，出栈是栈顶让位与他的下一个节点，明显的删除头节点操作。12345678910bool pop(NodeStack* &amp;stack, classname &amp;c)&#123; if (stack-&gt;next == NULL) return false; NodeStack* p = stack-&gt;next; c = p-&gt;data; stack-&gt;next = p-&gt;next; delete p; return true;&#125; 栈为空的条件还是要有的。 取顶我想知道栈顶究竟是何方人士，也只是想知道罢了。1234567bool topc(NodeStack* stack, classname &amp;c)&#123; if (stack-&gt;next == NULL) return false; c = stack-&gt;next-&gt;data; return true;&#125; 建栈栈是先进后出表，回想链表创建的两种办法——头插法和尾插法，头插法结果是反序，尾插法结果是正序。我想要我先插入的元素在后面，必然是相符与头插法喽。123456789101112131415161718void create(NodeStack* &amp;stack, classname a[], size_t n)&#123; init(stack); for (size_t i = 0; i &lt; n; i++) &#123; push(stack, a[i]); &#125; //或者如下写法 /*init(stack); NodeStack* p = stack; for (size_t i = 0; i &lt; n; i++) &#123; p = new NodeStack; p-&gt;data = a[i]; p-&gt;next = stack-&gt;next; stack-&gt;next = p; &#125;*/&#125; 注释部分其实是个头插法，只是把head换成stack罢了。 毁栈这就和销毁栈是一个意思了。1234567891011void destory(NodeStack* &amp;stack)&#123; NodeStack* q = stack; NodeStack* p = stack-&gt;next; while (p != NULL) &#123; delete q; q = p; p = p-&gt;next; &#125;&#125; 想说的话一路看完你会发现，栈的操作其实非常简单，是线性表操作的子集。然而栈的魅力之处不在于这些操作，而是在于数据的组织思想：先进后出。凡是需要先进后出的地方栈都有可用无之地，比如递归，比如括号匹配，比如函数的调用等等。有关于栈的一些应用日后会说。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>栈</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2017%2F03%2F27%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构已经把线性表给上完了，我也要记录点什么，不多说，进主题。 线性表是指那些在逻辑上的一个有限序列的一种数据结构，我们平日所见的表，数组等多是此种类型。至于按存储方式区分开来，包括但不限于顺序表和链表。本文便是记录顺序表和链表的基本含义和操作。说明：在这里我用C++语言来表述数据结构，为有条理和有层次，这里结构化书写，不封装成类。小表的排序统一使用简单插入增排序。 顺序表定义顺序表是一种定义在数组上的类型，既然是数组，免不了大小已经确定的问题，所以用maxsize来限制大小，可怎么也要有点个性啊，故用length来标记大小。1234567typedef int classname;const size_t maxsize = 99;struct SqLink&#123; classname data[maxsize]; size_t length;&#125;; 基本操作创建—create屌丝数组要变成高富帅顺序表了，OK，对号入座就行。123456789void create(SqLink* &amp;L, classname a[], size_t n)&#123; L = new SqLink; L-&gt;length = n; for (size_t i = 0; i &lt; L-&gt;length; i++) &#123; L-&gt;data[i] = a[i]; &#125;&#125; 初始化—init来一个空场地，至于有哪些人先别管。12345void init(SqLink* &amp;L)&#123; L = new SqLink; L-&gt;length = 0;&#125; 销毁—destory我喜欢删除，是格式化的那种。1234void destory(SqLink* &amp;L)&#123; delete L;&#125; 插入–insert想要在第order个位置插入某人c，首先得给它空个座位出来吧，怎么空座位？在这order位置后面的人统统往后挪一个位置就好了；然后它再无后虑之忧坐上去，因为这样就不会把其它人不小心的弄丢了。1234567891011bool insert(SqLink* &amp;L, size_t order, classname c)&#123; if (order &lt; 1 || order &gt; L-&gt;length + 1) //条件检测 return false; order--; for (size_t i = L-&gt;length; i &gt; order; i--) //往后挪位 L-&gt;data[i] = L-&gt;data[i - 1]; L-&gt;data[order] = c; L-&gt;length++; return true;&#125; 删除–del完了，我要被挤出去了，我能想象我被挤出去的时候，我后面的人就都要往前进一步的位置了，弟兄们，再见。12345678910bool del(SqLink* &amp;L, size_t order, classname &amp;c)&#123; if (order &lt; 1 || order &gt; L-&gt;length + 1) //条件检测 return false; c = L-&gt;data[--order]; for (size_t i = order; i &lt; L-&gt;length - 1; i++) //后齐进一 L-&gt;data[i] = L-&gt;data[i + 1]; L-&gt;length--; return true;&#125; 更新—update顺序表的每个人都擅长加工资。1234567bool update(SqLink* &amp;L, size_t order, classname c)&#123; if (order &lt; 1 || order &gt; L-&gt;length + 1) //条件检测 return false; L-&gt;data[--order] = c; //顺序表优势之一 return true;&#125; 查询—select相对来说，哪个人不老实也轻易感觉到。1234567bool select(SqLink* L, size_t order, classname &amp;c)&#123; if (order &lt; 1 || order &gt; L-&gt;length + 1) //条件检测 return false; c = L-&gt;data[--order]; //顺序表优势之二 return true;&#125; 排序—sort从我们打牌的时候给牌排序而得，从左往右，分有序区和无序区，开始只有第一个是有序区，后面的全为无序区。从第二个开始，我看看我应该在前面哪个正确的位置，然后我插入到那（插入？请先挪位）；接着第三个，我看看我应该在前面两个哪个位置，然后我插入那（插入？请先挪位）；接着第四个，我看看我应该在前面三个中哪个位置，插入到那（插入？请先挪位）……进行到最后一个，所有人都找到了正确的位置，于是便成了序。1234567891011121314void sort(SqLink *L)&#123; for (size_t i = 1; i &lt; L-&gt;length; i++) &#123; classname t = L-&gt;data[i]; size_t j = i-1; while (j &gt;= 0 &amp;&amp; L-&gt;data[j] &gt; t) //挪位 &#123; L-&gt;data[j + 1] = L-&gt;data[j]; j--; &#125; L-&gt;data[j+1] = t; &#125;&#125; 链表定义你会了单链表，触类旁通就很舒服了，所以我只说单链表，什么循环加双链的全都是我的继承者。走起。这链表啊，你别被他给吓着了，待我絮絮叨叨，你肯定认为啊不过如此，跟着我想象哦。假设你在这样一个房间里面，地上有一些封面没有书名的书，书名在哪呢，书名写在书里面去了，可是封面上面写了什么？上面写了一堆你看不懂的数字加英文组合，姑且把这个看不懂的数字加英文组合起个名字叫做id，id都是不同的，而且id和书本封面一体，不可修改，但这不妨碍你自己在一张纸上记录id，修改id，在一定程度上，id等于书。地上还有一只铅笔和一只橡皮擦；也有一些毫无内容的书，也就是没id没书名都空白的。现在，你有一个任务，把这些有id的书连接成一个相互有联系的一种状态，也就是书与书之间建立一对一的联系，怎么办？按id也就是数字加英文排序，那也太累了；随意排列，怕你记不住。聪明的你想到一个似乎一套可行的方案。这个方案就是我们接下来的重点了，先分析分析，不急。 解剖节点 数据域？是节点的内容吧，这个没什么，我用书名来替代你。 指针？知道你是拦路虎，也知道你是字母加数字组合，不过指向这个箭头是人赋予你含义的，OK，我看用id来代替你看可行不可行。 定义节点 这些书最后一页都留有一个空白的地方，是不是可以在这写上其它书的封面id呢？如果写上了，那把一本书看作一个节点，那么书里面就包含书名和id了，这个id还“指向”书呢，这也太像节点了！嗯，就这么干。 123456typedef int classname;struct Node&#123; classname data; Node *next;&#125;; 基本操作创建刚才留有一个任务说有id的书连接成一个相互有联系的一种状态，其实就是一种创建的过程了，依照刚才定义节点的思路，在书的最后一页用铅笔写上下一本书的id，至于下一本书是什么，不管，我在记录的时候手里从地上随便拿起的哪本书就是下一本书。一本接着一本记录下去，直到完毕。可是这样的话我必须不能忽略的一本书，那就是头一本书，它是那么的重要，有它我之前的记录才有意义，否则我下次需要展现这个成果的时候都不知道从哪一本书开始。想到这些，所以为表示第一本书的特殊，你在地上找到一本毫无空白没id没书名的书，你在这本书上刻上了id，不写书名，在最后一页记录下一本书的id，一个接着一个，像是一个链条似的。那么你的头一本书就像如下：1Node* head; 为了这个书链子有个终结的地方，你自己规定：哪一本书最后一本没写id，哪一本就是最后一本。没错，刚才的过程就是一个尾插法建表的过程。在最后一页写上下一本书的id是指针指向，在地上随手拿起一本书类似创建新节点的过程。这种建表符合逻辑（正序），再具体的就是如下的代码了。1234567891011121314void create(Node* &amp;head, classname a[], size_t n) //尾插法&#123; head = new Node; Node* p = head; Node* q = head; for (size_t i = 0; i &lt; n; i++) &#123; p = new Node; //拿起书本 p-&gt;data = a[i]; q-&gt;next = p; //在最后一页写id q = p; &#125; q-&gt;next = NULL;&#125; 现在要求你用和刚才对唱的办法建表，也就是在逻辑上反着的别扭建法，试想如下过程。有了头一本书head，拿起一本书，我在这本书上最后一页不写id，因为我想把这本书作为最后一本书；接着再拿起一本书，那么这本书肯定就是倒数第二本书了，故在最后一页写上最后一本的id，然后头一本书head的最后一页机上这本书id；接着再拿起一本，那么这本书得是倒数第三本书了，故在最后一页写上倒数第二本id，然后修改头一本书的id为这本书id；……如此下来，先拿起的书按次序排到后面了，后拿起的书按次序排到前面了，逻辑上反序成功。12345678910111213void create(Node* &amp;head, classname a[], size_t n) //头插法&#123; head = new Node; Node* p = head; head-&gt;next = NULL; for (size_t i = 0; i &lt; n; i++) &#123; p = new Node; p-&gt;data = a[i]; p-&gt;next = head-&gt;next; //指向它前面拿起的一本，想想，其实永远都是head的下一本 head-&gt;next = p; //head的下一本书是刚才拿起的 &#125;&#125; 初始化白手起家，手里只有空书。12345void init(Node* &amp;head)&#123; head = new Node; head-&gt;next = NULL;&#125; 销毁我要完全的毁尸灭迹，怎么办呢，我不能直接撕掉任何一本书，因为我要靠它找到下一本书并毁掉。所以我要做一个准备，在一张白纸上先记录下本书，再毁掉当前书本，又先记录后毁掉，如此进行直到最后。1234567891011void destory(Node* &amp;head)&#123; Node* q = head; Node* p = head-&gt;next; //记录下本书 while (p != NULL) &#123; delete q; //销毁当前书 q = p; //下一组 p = p-&gt;next; &#125;&#125; 插入嗯，你想把某本书c插到第order个位置，怎么也得先找到order-1个位置的书本，这时候你还不能直接改order-1个书本最后一页内容为c的id，否则这条书链就在这断了呀，原先的第order个的书本再也无法找到，为避免此种情况，必须先在某本书s最后一页写上原先的第order个书本，然后就改order-1个书本最后一页内容为c的id，这样才像个插入的样。123456789101112bool insert(Node* &amp;head, size_t order, classname c)&#123; Node* p = head; for (size_t i = 0; i &lt; order - 1 &amp;&amp; p != NULL; i++) p = p-&gt;next; if (p == NULL) return false; //是否找到第order-1本书p Node* q = new Node; q-&gt;data = c; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;&#125; 删除和之前销毁整条书链类似，同样和插入一个书本类似。先找到第order-1本书，这时候可以直接改最后一页的id内容为下一本的下一本了，那中间略过的一本书间接的被移除书链。12345678910111213bool del(Node* &amp;head, size_t order, classname &amp;c)&#123; Node* p = head; for (size_t i = 0; i &lt; order - 1 &amp;&amp; p != NULL; i++) p = p-&gt;next; if (p == NULL) return false; Node* q = p-&gt;next; if (q == NULL) return false; p-&gt;next =q-&gt;next; //条件满足，直接修改 c = q-&gt;data; delete q; return true;&#125; 更新一本书不满意自己的low书名，说：我要改书名。123456789bool update(Node* &amp;head, size_t order, classname c)&#123; Node *p = head; for (size_t i = 0; i &lt; order &amp;&amp; p != NULL; i++) p = p-&gt;next; if (p == NULL) return false; p-&gt;data = c; return true;&#125; 查询和更新类似123456789bool select(Node* head, size_t order, classname &amp;c)&#123; Node *p = head; for (size_t i = 0; i &lt; order &amp;&amp; p != NULL; i++) p = p-&gt;next; if (p == NULL) return false; c = p-&gt;data; return true;&#125; 排序只要你理解了顺序表里面的插入排序，你就能想象在链表里面该会是怎样的插入？没有了下标，就只能依靠id来了，同样，第一个有序，相当于重建一条链，后面的一个个的找到自己的位置，就这样，看下面，你能明白的。1234567891011121314151617void sort(Node* &amp;head)&#123; Node* p = head-&gt;next-&gt;next; head-&gt;next-&gt;next = NULL; //重建有序区 Node* q; Node* r; while (p != NULL) &#123; q = p-&gt;next; r = head; while (r-&gt;next != NULL &amp;&amp; r-&gt;next-&gt;data &lt; p-&gt;data) r = r-&gt;next; p-&gt;next = r-&gt;next; r-&gt;next = p; p = q; &#125;&#125; 其它形式的链表和想说的话 循环链表，尾节点指向头节点，那么循环结束的标志p-&gt;next != head; 双链表，分前驱指针和后继指针，不过是书的第一页写上上一本书的id，书的最后一页写上下一本书的id； 有序链表，说白了排好序的链表，不用你再排序了。 链表的基本算法都是相通的，时间复杂度几乎都是O(n)。 有机会补充链表的常见应用。 总结操作上，顺序表相对于链表，在插入和删除上不够灵活。链表相对于顺序表，在更新和查询上不那么给力。存储上，顺序表必拥有一片连续的内存区域，而链表则是随机的找内存区域。内容上，链表更装逼。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建个人博客]]></title>
    <url>%2F2016%2F12%2F17%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这里是在windows环境下，利用hexo搭建个人博客，其他系统的请绕道，我尽量以精简的步骤来引导新手。 如果你很想有一个自己的博客的话，就请先跟着流程走一遍！ 安装软件 Node.js Git 安装这两个软件没什么好说的，如果安装不上多下几个版本试试，并不要求什么最新版，虽然它们都是英文版的，安装完了就没事，只是利用其环境，不需操心。安装完后在桌面鼠标右键新增了Git Bash Here菜单项，继续往下。 搭建hexo hexo是个静态博客框架，说白了就是一个你本地的个人博客，最大好处就是里面有众多博客主题供你选择，不用你亲自写网页代码。 安装 这里假设你想把博客文件放在D:\blog文件夹下，开始以下步骤。 在D盘下新建一个名为blog的文件夹 选择该文件夹,鼠标右键选择Git Bash Here菜单项，弹出一个命令行黑窗，每条命令以$开头，输入命令后按Enter键执行命令。 执行$ npm install -g hexo-cli命令，为了安装hexo 执行$ hexo init命令，为了初始化博客框架 blog文件夹目录下产生新文件(5个)，则安装hexo成功，blog文件夹目录如下：12345678blog|—— _config.yml //站点配置文件|—— _package.json //应用程序的信息|—— scaffolds //模板文件夹|—— source //资源文件夹 |—— _drafts //草稿 |—— _posts //博文|—— themes //博客主题 本地部署 这里仍假设以D:\blog文件夹为例，开始如下步骤。 选择该文件夹，鼠标右键选择Git Bash Here菜单项，弹出黑窗 执行$ hexo s命令 在浏览器地址栏输入localhost:4000，得到的页面就是你本地服务器的博客 托管github github是一个代码托管的场所，可以简单的把它看作一个服务器（实际上没这么简单），配置好SSH keys(本地和github的一个桥梁)，刚才搭好的本地博客就可以放在github page上，从而实现本地博客走向网络平台。 注册github 进入github官网注册帐号，注册成功后假设你用户名是xxx，邮箱是yyy，之后出现xxx或yyy的地方请自行替代！。 新建github仓库 登录到github，找到并点击New repository后，Repository name必须填上xxx.github.io，然后直接点击Create repository完成新建仓库。 配置SSH keys 配置SSH keys是为了让本地的项目（如你的本地博客）和远程的github衔接起来，这是很重要的一步，给予重视。这里仍假设以D:\blog文件夹为例，开始如下步骤。 选择blog文件夹右键Git Bash Here，执行ssh-keygen -t rsa -C &quot;yyy&quot;，执行之后让你输入的均可以回车，以免麻烦。然而还是有必要解释一下，第一个让你输入的是SSH keys文件的路径，有默认路径（命令中括号括起来的路径）；第二个第三个输入的是密码和确认密码（输入的是暗文，没必要设置） 登录到github，进入刚刚新建的xxx.github.io，右上角有个可选项图标，选择Settings，之后选择SSH and GPG keys，选择New SSH key，title随意起名，key中的内容就是上一步骤中的SSH keys文件默认路径下的id_rsa.pub文件中的内容，复制粘贴过去即可 选择blog文件夹右键Git Bash Here，执行$ ssh -T git@github.com ，接着输入y，然后出现Hi ……的内容就说明以上步骤正确 接着执行$ git config --global user.name &quot;xxx&quot;，这步是用来提交你的用户名信息 接着执行$ git config --global user.email &quot;yyy&quot;，这步是用来提交你的邮箱信息 编辑blog文件夹下的_config.yml文件，到文件尾部，在最后一行type: 后输入 git(type:后空一个空格)，另起一行输入repo: git@github.com:xxx/xxx.github.io.git，再起一行输入branch: master，这步是填写github的上传地址（git@github.com:xxx/xxx.github.io.git）和分支（master)，即如下样式:1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 在线浏览 执行$ npm install hexo-deployer-git --save安装hexo-deployer-git 在成功完成稍微麻烦的步骤3后，选择blog文件夹，执行hexo d -g命令后，打开浏览器，地址栏输入xxx.github.io（xxx是你的用户名），你可以看到在线的博客了，而不是依靠localhost的4000端口，如果你想继续和你的域名绑定的话，接着往下。 绑定域名 如果你不满足于用xxx.github.io网址来进入你的博客的话，想要用自己的专属域名来提高个性度，可以按以下步骤实现。 假定你有域名abc.com，没有的自行注册，推荐去有学生优惠的腾讯云购买仅需1元的个人域名(期限一年，现在没了)。添加两个A记录类型的解析，一个记录值为192.30.252.153，另一个记录值为192.30.252.154，说明一下，这两个ip地址其实是github page的主用地址和备用地址。 继续解析，添加CNAME类型的记录，记录值为xxx.github.io，xxx是你的用户名 在blog/source文件夹下新建名为CNAME的文件（无后缀名），内容是abc.com，abc.com是你的域名! 选择blog文件夹，执行hexo d -g命令，等待10分钟 浏览器输入你的域名如abc.com，初步完成你的博客搭建 后续 按照以上的步骤你能得到一个默认的博客主题网站，你还需要对主题配置等修修改改，还需要选择一个自己满意的博客主题后又修修改改，都需要去折腾来折腾去，祝你好运。just do it! 推荐网址 hexo中文官方文档 hexo博客主题 10小时内搭建个人博客]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C++泛型编程的浅浅理解]]></title>
    <url>%2F2016%2F12%2F10%2FC%2B%2B%E6%B3%9B%E5%9E%8B%E5%B0%8F%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[C++和C语言有两个重要的区别，一个是引入面向对象编程（OOP）的编程机制，另一个则是泛型编程机制了。虽然说在c语言当中可以利用指向空类型的指针来指向任意对象，通过这种隐式转换，实现了一定的泛型编程（仅对于面向过程的函数而言），但是这种方法显然需要足够的小心，太过于不安全。而c++从内部语法上深度支持泛型编程，而且对应与函数模板和类模板，只要你恰当的使用关键字template即可。 函数模板 语法示例template&lt;typename T&gt; void functionname(T a);其实只要在普通函数前添加template&lt;typename T&gt;后面需要模板化的类型用T代替就好。类模板 语法示例template&lt;typename T&gt; class classname;和通常类的定义一样，加上关键字template&lt;typename T&gt;，主要在里面需要类型名参数化的地方用上T就好。注意点 一个template只管一个函数或者类型，需要的话则另行定义，二者不冲突。 模板的参数是在运行时初始化的，这意味着 在声明模板的地方你必须定义好它 模板的bug通常隐蔽在运行之中，且难以察觉 以上是新学模板时需要格外重视的地方，下面说说我对模板的浅浅理解。 在使用过容器后我才知道vector就是一个类模板（原谅我的无知），里面给你定义好了需要的动作，比如添加元素（顶），取出元素（顶），迭代器等非常实用的成员函数，就拿上一次的成绩管理系统来说，用容器写比自个用链表写的就方便很多，而且你不用担心会出错，这是我感受到模板的强大之处之一，提现了模板内部良好的封装性，而封装也是我们希望的。 在STL源码内部也可以说就是由一个个模板组成的标准类库，在c++ template也说起模板是最小的组成单位，类隐没在模板之中，函数隐没在模板之中，当然有基础的不需要模板的地方，不过只是很小的比例，如果你想写大的话。 我们来设想一下c++语言没有模板这个语言特性，为对一些不同的类型实现相同的功能，你只能使用如下糟糕办法： 针对每一种类型一次又一次地去实现它，显而易见，大量的重复工作！ 把实现代码放在一个公共基础类（Java里面是Object,C++你可以自己定义这样一个父类，该父类派生每一种类型）或者void*（思想和c语言相同）里面，然而这样会让传参类型难于检查，对需要增加的新的实现的类，都要继承自特定基类，维护困难！ 使用特殊的预处理程序（宏），你会感觉文本替换不像是代码的格式，而且预处理注定不考虑作用域和类型！ 以上从反例说明了应用模板特性的优良解决方案，模板运行时接受类型实参，而且支持类型检查和作用域。 嗯，到此为止吧。]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择性编译]]></title>
    <url>%2F2016%2F11%2F27%2F%E9%80%89%E6%8B%A9%E6%80%A7%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[类的继承在面向对象的c++程序设计语言里是如此普遍，而且我们为了文档结构到最后不至于混乱，总会是一个h文件写类的声明，另一个cpp文件写类的定义，这样在测试该类的时候只需#include这个h文件即可，可有一个问题会悄然发生，当某个cpp文件需要父类又需要子类的h文件时，即#include“A.h”#include”B.h”B是A的子类，就会发生一个问题，重复编译A.h，这时就要用到选择性编译指令了。 需要用到的预编译指令有#define， #ifdef， #ifndef， #endif。很好理解，define：宏定义，ifdef：如果定义，ifndef：如果没有定义，endif：结束if指令。下面来看看一个例子。A.h文件如下： 12345class A&#123;public: A()&#123;&#125;&#125;; B.h文件如下： 123456#include"A.h"class B: public A&#123;public: B():A()&#123;&#125;&#125;; 若在某个文件中包含如下语句： 12#include"A.h"#include"B.h" 在这先不问直接加载一个”B.h”不就可以了么，而是为了防止这样的语句出现在长长的cpp文件而出现的编译错误该怎样来有效解决。以下是一个解决方案，修改后的文件结构如下。A.h文件如下 123456#define AKclass A&#123;public: A()&#123;&#125;&#125;; B.h文件如下 12345678#ifndef AK#include"A.h"#endifclass B: public A&#123;public: B():A()&#123;&#125;&#125;; 可以看见，只需在A.h文件定义一个标志宏名，然后在B.h文件中判断该标志宏名有没有被定义，没有则加载，有则不再重复加载。以上只是一个简单的继承关系，事实上，当每个继承关系发生时，都该采取类似的选择性编译来保证被加载的无错性。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++二进制文件的读写操作]]></title>
    <url>%2F2016%2F11%2F27%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[相比于普通的文本文件，二进制文件的以字节为存储单位多出了许多优点，下面是有关二进制文件的读写操作。主要用到两个函数，在头文件fstream中。读read，写write。下面详情。（一）写操作。1ofstream write(char *buffer, int length) buffer是变量指针，一般需要强制转化成char *类型，然后加取地址符，因为任何内容都可以表现成字符的形式，而后面的length则是变量类型的字节长，一般用sizeof进行计算防止不必要的错误，下面看实例。 12345678910#include&lt;fstream&gt;int main()&#123; using namespace std; int a = 1127; double b = 3.1415; ofstream ofs("test.txt",ios::binary); ofs.write((char*)&amp;a,sizeof(int)); ofs.write((char*)&amp;b,sizeof(double));&#125; 注：（其中ios::binary以二进制方式打开文件）（二）读操作。1ifstream read(char * buffer, int length) 参数和刚才一样的道理，下面看将上文的a,b输出到控制台。 1234567891011121314151617181920#include&lt;fstream&gt;int main()&#123; using namespace std; int a = 1127; double b = 3.1415; ofstream ofs("test.txt",ios::binary); ofs.write((char*)&amp;a,sizeof(int)); ofs.write((char*)&amp;b,sizeof(double)); ofs.close(); int a1; double b1; ifstream ifs("test.txt",ios::binary); ifs.read((char*)&amp;a1,sizeof(int)); cout&lt;&lt;a1&lt;&lt;endl; ifs.read((char*)&amp;b1,sizeof(double)); cout&lt;&lt;b1&lt;&lt;endl; ifs.close(); return 0;&#125; 其实道理很简单，应用此模式，数据类型复杂一些像结构也照样可以进行读写操作。例如。 12345678910111213141516171819202122#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;struct A&#123; int a; double b;&#125;;int main()&#123; using namespace std; A aa=&#123;1127,3.1415&#125;; ofstream ofs("test.txt",ios::binary); ofs.write((char*)&amp;aa,sizeof(A)); ofs.close(); A bb; ifstream ifs("test.txt",ios::binary); ifs.read((char*)&amp;bb,sizeof(A)); cout&lt;&lt;bb.a&lt;&lt;endl; cout&lt;&lt;bb.b&lt;&lt;endl; return 0;&#125; 关于二进制文件的读写就到这里了。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承方式和多态体现]]></title>
    <url>%2F2016%2F11%2F13%2F%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E6%80%81%E4%BD%93%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[相比于java，c++的继承支持多继承，还支持选择多种继承方式。今天重点讲解c++的三种继承方式。如下 公有继承。 派生类可以完成向上转型。 基类的public，protected，private成员在派生类依旧分别为public，protected，private成员。 第二条意味着，派生的对象只可访问public成员。 保护继承。 派生类不可完成向上转型。 基类的public，protected，private成员在派生类依旧分别为protected，protected，private成员。 第二条意味着，派生类的对象无法访问任何成员（父类继承而来的），还意味着，派生类的派生类将延续这个性质。 私有继承。 派生类不可完成向上转型。 基类的public，protected，private成员在派生类依旧分别为private，private，private成员。 第二条意味着，派生类的对象无法访问任何成员（父类继承而来的），还意味着，派生类的派生类将继承这个性质。 下面讲讲多态的主要体现方式。 编译时多态。这个主要体现在派生类和基类成员函数之间的隐藏和覆盖关系。只有在基类成员函数是虚函数并且基类成员函数和派生类成员函数的函数名和参数列表相同时，才发生覆盖。而其它的派生类成员函数和基类成员函数同名的情况都属于隐藏。还有就是手动的向上转型。 运行时多态这时候virtual的作用完全体现了出来。通过运行时向上转型的自动识别来运行指定的类的成员函数，完成了我们想要的运行的结果，这种方式的多态方式一般还有一个更装逼的名字：动态联编。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇的C++实现]]></title>
    <url>%2F2016%2F11%2F11%2F%E8%B4%AA%E5%90%83%E8%9B%87%E7%9A%84C%2B%2B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[贪吃蛇是个很好的练习材料。 对玩游戏稍有了解就会发现，几乎所有游戏不外乎都是一个初始化，循环过程和结束的集合，而游戏规则就蕴含于循环过程之中，也是整个游戏的核心。经典游戏贪吃蛇的规则想必都知道，不再赘述，这里的重点是何如实现它，即在控制台上真切的实现该游戏的过程。 初始化可以想象，刚开始的界面是4堵围墙和静止的一条小蛇，一颗果实，一个计分器，也可以加点别的东西。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182void Pos(short x,short y)//设置光标位置函数.&#123; COORD pos; pos.X=x; pos.Y=y; HANDLE hOutput=GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput,pos);&#125;void CreateMap()//打印地图&#123; //打印上下边框,这里每次自增2是因为控制台的一行和一列 //的宽度不同，且恰好有两倍关系。 for(int i=0;i&lt;57;i+=2) &#123; Pos(i,0); printf(&quot;■&quot;); Pos(i,24); printf(&quot;■&quot;); &#125; for(int i=1;i&lt;24;i++)//打印左右边框 &#123; Pos(0,i); printf(&quot;■&quot;); Pos(56,i); printf(&quot;■&quot;); &#125; return;&#125;struct Body//定义蛇身结构体&#123; short x,y;//蛇身结点的坐标 Body *next;//指向下一个结点的指针&#125;;void PrintSnake()//打印蛇&#123; Body *p=body001; while(p!=NULL)//判断是否指向蛇尾 &#123; Pos(p-&gt;x,p-&gt;y); printf(&quot;■&quot;); p=p-&gt;next; &#125;//从蛇头打印到蛇尾 return ;&#125;int Food=0; //1表明有食物，0表明没食物short food_x,food_y;//食物坐标void CreateFood()//创建新食物&#123; if(Food==0) &#123; srand((int)time(0)); food_x=2+rand()%53;//x的取值范围[2,54] if(food_x%2==1) food_x--; food_y=1+rand()%23;//y的取值范围[1,23] Food=1; &#125;&#125;Body *body001;//蛇头指针,判断方向，宜做全局变量void Init()//游戏初始化&#123; CreateMap(); Body *body002,*body003,*body004; body001=new Body;//创建4个蛇身结构体 body002=new Body; body003=new Body; body004=new Body; body001-&gt;next=body002;//把蛇身连接起来，形成链表 body002-&gt;next=body003; body003-&gt;next=body004; body004-&gt;next=NULL; Pos(body001-&gt;x=12,body001-&gt;y=8);printf(&quot;■&quot;);//设定并打印蛇身的初始位置 Pos(body002-&gt;x=10,body002-&gt;y=8);printf(&quot;■&quot;); Pos(body003-&gt;x=8,body003-&gt;y=8);printf(&quot;■&quot;); Pos(body004-&gt;x=6,body004-&gt;y=8);printf(&quot;■&quot;); CreateFood();//创建食物&#125; 规则好了，现在进行一个关键步骤，就是蛇的移动问题。我想的是，蛇的移动分为两种情况，就是蛇的下一步有没有食物。若没有食物，则在下一步位置创建蛇身结构体，作为蛇头，然后把蛇尾删除。若是有食物，则在食物位置创建结构体，作为蛇头，不删除蛇尾。这一步代码包含蛇的一步移动问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132void SnakeMove()//蛇身移动、刷新蛇身和食物及其坐标&#123; Body *p_food;//下一格有食物 Body *p_forward;//下一格没食物 Body *q;//蛇身移动一格时的临时指针 p_forward=new Body; if(1==dir)//向上移动 &#123; if(body001-&gt;x==food_x &amp;&amp; body001-&gt;y-1==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Pos(62,3);printf(&quot;分数:%d&quot;,score); Food=0; CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x;//横坐标不变 p_forward-&gt;y=body001-&gt;y-1;//纵坐标-1 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125;//else &#125; if(2==dir)//向下移动 &#123; if(body001-&gt;x==food_x &amp;&amp; body001-&gt;y+1==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Pos(62,3);printf(&quot;分数:%d&quot;,score); Food=0; CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x;//横坐标不变 p_forward-&gt;y=body001-&gt;y+1;//纵坐标+1 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125;//else &#125; if(3==dir)//向左移动 &#123; if(body001-&gt;x-2==food_x &amp;&amp; body001-&gt;y==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Pos(62,3);printf(&quot;分数:%d&quot;,score); Food=0; CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x-2;//横坐标-2 p_forward-&gt;y=body001-&gt;y;//纵坐标不变 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125; &#125; if(4==dir)//向右移动 &#123; if(body001-&gt;x+2==food_x &amp;&amp; body001-&gt;y==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Food=0; Pos(62,3);printf(&quot;分数:%d&quot;,score); CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x+2;//横坐标=2 p_forward-&gt;y=body001-&gt;y;//纵坐标不变 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125; &#125; Pos(food_x,food_y);printf(&quot;■&quot;);//打印食物 PrintSnake();//打印蛇&#125; 规则检查容易看出，其实上一步是整个游戏的核心，每走一步就重新打印蛇，意味着这个函数需要放在一个循环里面。接下来实现游戏规则：不能碰墙和撞到自己。代码如下：1234567891011121314151617181920int TouchSelf()//判断是否咬到自己&#123; Body *p_tself; p_tself=body001; while(!p_tself-&gt;next==NULL) &#123; p_tself=p_tself-&gt;next; if(p_tself-&gt;x==body001-&gt;x &amp;&amp; p_tself-&gt;y==body001-&gt;y) return 1; &#125; return 0;&#125;int TouchWall()//不可穿墙&#123; if(body001-&gt;x==0 || body001-&gt;x==56 || body001-&gt;y==0 || body001-&gt;y==24) return 1; else return 0;&#125; 循环把游戏的进行的每一步和每一步的规则检查放入整个游戏循环，触碰规则则游戏结束。123456789101112131415161718192021void GameCircle()//游戏循环&#123; while(1) &#123; if (1== TouchWall())//不可穿墙 break;//撞墙Game Over if(1== TouchSelf() )//判断蛇是否咬到自己 break;//咬到自己Game Over //判断用户的按键输入 if(GetAsyncKeyState(VK_UP) &amp;&amp; dir!=2) dir=1; else if(GetAsyncKeyState(VK_DOWN) &amp;&amp; dir!=1) dir=2; else if(GetAsyncKeyState(VK_LEFT) &amp;&amp; dir!=4) dir=3; else if(GetAsyncKeyState(VK_RIGHT) &amp;&amp; dir!=3) dir=4; SnakeMove();//蛇移动一格 Sleep(sleeptime);//设定两次移动之间的时间间隔 &#125;&#125; 结束对于游戏规则来说，顺我者昌，逆我则亡。12345678void EndImage() //游戏结束画面&#123; system(&quot;cls&quot;); Pos(30,9);printf(&quot;游戏结束，欢迎再来！&quot;); Pos(30,11);printf(&quot;你的得分：%d&quot;,score); Pos(28,13); system(&quot;pause&quot;);&#125; 游戏实现入口1234567int main()&#123; Init(); GameCircle(); EndImage(); return 0;&#125; 到此结束，贴出整个代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include&lt;windows.h&gt;#include&lt;conio.h&gt;#include&lt;cstdlib&gt;#include&lt;time.h&gt;#include&lt;iostream&gt;using namespace std;void Pos(short x,short y)//设置光标位置函数&#123; COORD pos; pos.X=x; pos.Y=y; HANDLE hOutput=GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput,pos);&#125;void CreateMap()//打印地图&#123; for(int i=0;i&lt;57;i+=2)//打印上下边框,这里每次自增2是因为控制台的一行和一列的宽度不同，且恰好有两倍关系。 &#123; Pos(i,0); printf(&quot;■&quot;); Pos(i,24); printf(&quot;■&quot;); &#125; for(int i=1;i&lt;24;i++)//打印左右边框 &#123; Pos(0,i); printf(&quot;■&quot;); Pos(56,i); printf(&quot;■&quot;); &#125; return;&#125;//接下来定义结构体从而创建链表。struct Body//定义蛇身结构体&#123; short x,y;//蛇身结点的坐标 Body *next;//指向下一个结点的指针&#125;;int Food=0; //1表明有食物，0表明没食物short food_x,food_y;//食物坐标void CreateFood()//创建新食物&#123; if(Food==0) &#123; srand((int)time(0)); food_x=2+rand()%53;//x的取值范围[2,54] if(food_x%2==1) food_x--; food_y=1+rand()%23;//y的取值范围[1,23] Food=1; &#125;&#125;Body *body001;//蛇头指针void Init()//游戏初始化&#123; CreateMap(); struct Body *body002,*body003,*body004;//定义四个指向蛇身的指针 body001=new Body;//创建4个蛇身结构体 body002=new Body; body003=new Body; body004=new Body; body001-&gt;next=body002;//把蛇身连接起来，形成链表 body002-&gt;next=body003; body003-&gt;next=body004; body004-&gt;next=NULL; Pos(body001-&gt;x=12,body001-&gt;y=8);printf(&quot;■&quot;);//设定并打印蛇身的初始位置 Pos(body002-&gt;x=10,body002-&gt;y=8);printf(&quot;■&quot;); Pos(body003-&gt;x=8,body003-&gt;y=8);printf(&quot;■&quot;); Pos(body004-&gt;x=6,body004-&gt;y=8);printf(&quot;■&quot;); CreateFood();//打印食物&#125;void PrintSnake()//打印蛇&#123; Body *p=body001; while(p!=NULL)//判断是否指向蛇尾 &#123; Pos(p-&gt;x,p-&gt;y); printf(&quot;■&quot;); p=p-&gt;next; &#125;//从蛇头打印到蛇尾 return ;&#125;int dir=4;//蛇头方向1-up,2-down,3-left,4-rightint sleeptime=220;//每次移动之后的停顿时间int score;//玩家得分void SnakeMove()//蛇身移动、刷新蛇身和食物及其坐标&#123; Body *p_food;//下一格有食物 Body *p_forward;//下一格没食物 Body *q;//蛇身移动一格时的临时指针 p_forward=new Body; if(1==dir)//向上移动 &#123; if(body001-&gt;x==food_x &amp;&amp; body001-&gt;y-1==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Pos(62,3);printf(&quot;分数:%d&quot;,score); Food=0; CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x;//横坐标不变 p_forward-&gt;y=body001-&gt;y-1;//纵坐标-1 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125;//else &#125; if(2==dir)//向下移动 &#123; if(body001-&gt;x==food_x &amp;&amp; body001-&gt;y+1==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Pos(62,3);printf(&quot;分数:%d&quot;,score); Food=0; CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x;//横坐标不变 p_forward-&gt;y=body001-&gt;y+1;//纵坐标+1 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125;//else &#125; if(3==dir)//向左移动 &#123; if(body001-&gt;x-2==food_x &amp;&amp; body001-&gt;y==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Pos(62,3);printf(&quot;分数:%d&quot;,score); Food=0; CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x-2;//横坐标-2 p_forward-&gt;y=body001-&gt;y;//纵坐标不变 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125; &#125; if(4==dir)//向右移动 &#123; if(body001-&gt;x+2==food_x &amp;&amp; body001-&gt;y==food_y)//下一格有食物 &#123; p_food=new Body; p_food-&gt;x=food_x; p_food-&gt;y=food_y; p_food-&gt;next=body001; body001=p_food; score+=5; Food=0; Pos(62,3);printf(&quot;分数:%d&quot;,score); CreateFood(); &#125; else//下一格没有食物 &#123; p_forward-&gt;x=body001-&gt;x+2;//横坐标=2 p_forward-&gt;y=body001-&gt;y;//纵坐标不变 p_forward-&gt;next=body001; body001=p_forward; q=body001; while((q-&gt;next)-&gt;next!=NULL)//使q指向倒数第二个结点 q=q-&gt;next; Pos((q-&gt;next)-&gt;x,(q-&gt;next)-&gt;y);//移动光标到蛇尾 printf(&quot; &quot;);//删除蛇尾 free(q-&gt;next); //释放蛇尾 q-&gt;next=NULL;//使倒数第二个结点成为新的蛇尾 &#125; &#125; Pos(food_x,food_y);printf(&quot;■&quot;);//打印食物 PrintSnake();//打印蛇&#125;int TouchSelf()//判断是否咬到自己&#123; Body *p_tself; p_tself=body001; while(!p_tself-&gt;next==NULL) &#123; p_tself=p_tself-&gt;next; if(p_tself-&gt;x==body001-&gt;x &amp;&amp; p_tself-&gt;y==body001-&gt;y) return 1; &#125; return 0;&#125;int TouchWall()//不可穿墙&#123; if(body001-&gt;x==0 || body001-&gt;x==56 || body001-&gt;y==0 || body001-&gt;y==24) return 1; else return 0;&#125;void GameCircle()//游戏循环&#123; while(1) &#123; if (1== TouchWall())//不可穿墙 break; if(1== TouchSelf() )//判断蛇是否咬到自己 break;//咬到自己Game Over //判断用户的按键输入 if(GetAsyncKeyState(VK_UP) &amp;&amp; dir!=2) dir=1; else if(GetAsyncKeyState(VK_DOWN) &amp;&amp; dir!=1) dir=2; else if(GetAsyncKeyState(VK_LEFT) &amp;&amp; dir!=4) dir=3; else if(GetAsyncKeyState(VK_RIGHT) &amp;&amp; dir!=3) dir=4; SnakeMove();//蛇移动一格 Sleep(sleeptime);//设定两次移动之间的时间间隔 &#125;&#125;void EndImage()&#123; system(&quot;cls&quot;); Pos(30,9);printf(&quot;游戏结束，欢迎再来！&quot;); Pos(30,11);printf(&quot;你的得分：%d&quot;,score); Pos(28,13); Sleep(5000);&#125;int main()&#123; Init(); GameCircle(); EndImage(); return 0;&#125;]]></content>
      <categories>
        <category>语言设计</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小动画效果]]></title>
    <url>%2F2016%2F10%2F30%2F%E5%B0%8F%E5%B0%8F%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[最近想写一个贪吃蛇游戏，做了几个准备动作，其中就包含了简单的动画实现效果，主要是利用了windows.h和conio.h两个头文件。 第一步，光标跳到指定位置。在控制台窗口中，默认的光标在输入位置一个一个走动，太规矩。想改变的话，可以把控制台的标准输出窗口句柄得到GetStdHandle(STD_OUTPUT_HANDLE)（你可以理解为窗口的唯一标识）后利用函数SetConsoleCursorPositon(HANDLE,COORD)。这里的HANDLE就是窗口句柄，GetStdHandle(STD_OUTPUT_HANDLE)作为第一个参数，COORD是坐标对象，该对象成员只有两个X和Y,即坐标的具体位置。 12345678#include&lt;windows.h&gt;void gotoxy(int x, int y)&#123; COORD coord; coord.X = x; coord.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),coord);&#125; 很简单的吧，通过调用这个gotoxy(a,b)函数，光标会跳到（a，b）位置，（a，b）表示第b列第a列，从（0,0）（屏幕左上边缘）开始。 第二步时间控制，平常的输出都是瞬间输出完毕，让人感受不到“动”的效果。在windows.h中有个Sleep（int）函数，接收参数表示暂停时间，单位秒。第三步获取键盘输入，在conio.h中有_kbhit()函数，若有输入则返回真，无者假。会了这三个函数，就能实现简单的动画效果了。整个代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;conio.h&gt;#include&lt;windows.h&gt;using namespace std;void gotoxy(int x, int y)&#123; COORD coord; coord.X = x; coord.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),coord);&#125;int main()&#123; /*while(1) &#123; if(_kbhit()) &#123; printf("按下了键盘!\n"); int c = getch(); switch(c) &#123; case 65: printf("你按下了A\n"); break; case 66: printf("你按下了B\n"); break; default: printf("其他\n"); &#125; &#125; &#125;*/ int x = 0; int y = 0; while(1) &#123; gotoxy(0, 0); printf("%d", x++); Sleep(1000); &#125; return 0;&#125; 代码中被注释部分是实现按键检测的功能。运行效果可去复制体会。另外，有了这些知识，可以试着完成wsad控制单个字符的移动的功能。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类与对象的使用3]]></title>
    <url>%2F2016%2F10%2F23%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A83%2F</url>
    <content type="text"><![CDATA[这节的主题是关于类的常成员。首先明确一个观念，常成员很重要，很重要，很重要。 我们设计常成员是为了一经初始化就不允许再改变，毫无疑问，常成员初始化的地方是构造函数，而且必须是初始化列表当中，因为初始化的列表这块先执行，然后再执行函数体。如下， 123456class A&#123;const int a;public:A(int a_): a(a_)&#123;&#125;&#125;; 接着是常成员函数，你需要注意的是常是一个函数的一部分，一个标识（像返回类型），这是和静态函数需要区分开来的地方。常成员函数就是用来保护成员不受改变，但凡你觉得这个函数不应该改动成员，你都应该设它为常成员函数。 依照上面的性质，常成员函数不能调用非常成员函数，因为后者有改动数据的可能；常成员函数不能调用非常成员变量，显而易见。在说说函数参数的常引用。因为类数据的复杂性，如果每次传参都需要临时拷贝，太耗资源，所以传引用解决这问题；因为我们通常希望实参不受改变，所以用const解决这个问题。 最后讲一讲常对象， 常对象和你之前知道的const int a 一样，不过是把封装了一大群成员，每一个成员变量（不包含静态成员）只允许读而不允许写。 有关于常主要的东西大概这么些，有疑问的地方尽管提问。end]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类与对象的使用2]]></title>
    <url>%2F2016%2F10%2F16%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A82%2F</url>
    <content type="text"><![CDATA[这节主要话题是静态类成员，因为普通成员没啥讲的。请记住，我们设计静态类成员就意味着类需要公有成员和公有函数，这里的公有不是指public属性（当然，设置成public才有意义），而是指这个类共享使用这个成员和函数。以上是简单的概述它们的主要作用。下头说说它们的具体实现细节。bingo，上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class incomec&#123;public: double income; //实际收入 static double wage; //工资 static double taxrate;//税率 void setWage(); //输入工资 static double getTaxrate(); //得到税率 static double callncome(); //计算收入&#125;;void incomec::setWage()&#123; cout &lt;&lt; "please input your wage: "; cin &gt;&gt; wage;&#125;double incomec::getTaxrate()&#123; taxrate = 0; if(wage &gt; 2000) taxrate = 0.05; if(wage &gt; 4000) taxrate = 0.10; if(wage &gt; 7000) taxrate = 0.15; if(wage &gt; 12000) taxrate = 0.20; return taxrate;&#125;double incomec::callncome()&#123; return ((wage - 2000) * (1 - taxrate) + 2000);&#125;double incomec::taxrate = 0; //请注意格式double incomec::wage = 0;int main()&#123; incomec in1; in1.setWage(); in1.getTaxrate(); //也可以incomec::getTaxrate in1.income = in1.callncome(); cout &lt;&lt; "this is your income: " &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; in1.income &lt;&lt; endl; return 0;&#125; 这是某个实验试题，主要让学生来试试静态的水到底怎样深与浅。 在这个程序里面，定义了一个收入类，里面普通成员有工资，静态成员收入，税率，普通函数有设置工资，静态函数有得到税率，计算收入。其实大家可以发现这样的设计类是非常的不合乎逻辑，是在闹玩笑，进一步说明这个实验是个低级玩具，只供概念测试。 不难得到静态成员和普通成员区别在于加了一个关键字static，而且类里面只是声明，定义该成员需要在类外进行。其实静态成员的存储区和全局变量在一个地方，明白这也可以更好的理解静态成员了。 另外，C++规定静态函数不能访问非静态成员。这跟常成员函数不能调用非成员函数是一个道理。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类与对象的使用1]]></title>
    <url>%2F2016%2F10%2F09%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A81%2F</url>
    <content type="text"><![CDATA[这次的主题是关于构造函数和析构函数。 类的构造函数帮助类初始化对象的数据成员，任何对象的创建都会执行构造函数。 可以轻易地知道构造函数既有函数之名，很多地方可以说与普通函数无所区别。只有三个地方特异，一是函数名必须与类名相同，二是无返回类型，三是拥有初始化列表（唯一初始化const成员的地方，初始化顺序同样由函数参数列表决定（由右向左的顺序初始化））。其实还有一个值得注意的地方是构造函数不能定义成const类型，其中一个原因是方便创建一个const类型对象。 类的析构函数帮助类清理对象（栈区）所占空间，在在每一个对象的生命周期完毕时调用。 析构函数同样固定了函数名——~类名，没有返回类型，不能定义成const类型（对象都要被销毁了）。而且类里面定义有指针成员时，一般在析构函数里头delete指针成员，因为自己用指针开辟的内存区域不在栈区，而在堆区。调用析构函数的次序和对象作用区域内调用构造函数的次序相反。 下面来一小段代码。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class demo&#123;int a;int *p;public: demo():a(0) &#123; cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl; p = new int(0); &#125; ~demo() &#123; cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl; delete p; &#125;&#125;;int main()&#123; demo B, *C; C = new demo; delete C; return 0;&#125; 12345运行结果1：调用构造函数调用构造函数调用析构函数调用析构函数 若是把C = new demo;和delete C注释掉，123则运行结果2：调用构造函数调用构造函数 若是把delete C注释掉，1234则运行结果3：调用构造函数调用构造函数调用析构函数 由运行结果1和2，容易想像到声明对象指针不调用构造函数，只有该指针new demo时才开始调用； 再由运行结果1和3，也可以清楚的知道在delete对象指针时实质上是调用了类的析构函数，至于原因，你可以把delete看作一个函数，右边跟着的是它的参数，在本程序中右边跟着的是demo类型实参，在声明delete的时候形参肯定不是demo类型的，所以把该实参地址传给类的析构函数，因为析构函数能清楚的销毁这个对象。 构造和析构函数在继承方面的问题，下面也简单说说。因为创建派生类对象时一定会调用该类的父类的构造函数，层层往上，直到一定会调用最高层级的父类的构造函数。所以在创建派生类对象时，从最高层级父类开始调用，再到下一层，直到本类构造函数。而析构函数和构造函数相反，所以析构的对象从本派生类开始，之后，若是该派生类里面还定义有非基本类型的成员，则析构该成员对象，之后，再往上一层父类，同理，一直到最高层级父类才结束。有关于构造和析构的讲解到此结束，还有疑问的地方欢迎提问。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件流再探]]></title>
    <url>%2F2016%2F10%2F09%2F%E6%96%87%E4%BB%B6%E6%B5%81%E5%86%8D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[来一小段代码： 12345678910111213141516171819202122#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int main()&#123; ifstream in_stream; ofstream out_stream; in_stream.open("D:c++\infile.txt");//问题1 out_stream.open("outfile.txt"); int a, b; if(in_stream.fail())&#123; //问题2 cout &lt;&lt; "failed" &lt;&lt; endl; exit(1); &#125; in_stream &gt;&gt; a &gt;&gt; b; out_stream &lt;&lt; "a + b = " &lt;&lt; (a+b) &lt;&lt; endl; in_stream.close(); out_stream.close(); return 0;&#125; 现在来看第一个小问题： in_stream.open(&quot;D:c++\infile.txt&quot;);//问题1 调用成员函数open参数文件名的规范，我们知道，一个完整的文件名是包含这个文件的路径及其文件名的，现在我把完整的文件名作为参数，为什么会有错误？呵，仔细想想一个细节，\字符需要转义(\\)。所以这里应当改回： in_stream.open(&quot;D:c++\\infile.txt&quot;);//问题1正解 第二个重要的问题就是检查流操作的正确性： 1234if(in_stream.fail())&#123; //问题2 cout &lt;&lt; "failed" &lt;&lt; endl; exit(1); &#125; 我们常常需要判断一个流对象是否成功连接到一个文件，因此，在一个流对象调用open之后总应该调用fail来测试，这也是一个必要的习惯。成员函数fail不接受任何参数，返回一个bool类型。它的原型是bool ifstream::fail();和 bool ofstream::fail();。这样，能清楚地知道文件的连接是否到位。接下来就说另一个重要的成员函数eof。用它来判断文件尾，它同样不接受任何参数，返回bool值。例如以下语句： 123if(!in_stream.eof())&#123; cout &lt;&lt; "Not done" &lt;&lt; endl;&#125;else cout &lt;&lt; "file done" &lt;&lt; endl; 至于为甚么需要预判文件尾，一个原因是在程序运行过程中，流对象从不返回来去读取已经读取过的内容，即像时间一样不去倒流。最后补充一个关于输出文件的小技巧，你若想要把内容写入到一个已经存在的文件中，而且又不想覆写这个文件，只想把内容追加到文件尾，那么你可以这样调用open： out_stream.open(&quot;outfile.txt&quot;,ios::app); //两个参数 1 这样你这次输出的内容会追加到outfile.txt（已经存在）的文件尾了。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试C++文件流]]></title>
    <url>%2F2016%2F09%2F07%2F%E5%88%9D%E8%AF%95C%2B%2B%E6%96%87%E4%BB%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[在初学C++的时候，有时候往往需要多次输入来实验一个程序，若程序需要输入的次数尚少，在忍受的范围之内则不会说些什么；可若是需要大量输入，比如创建结构体类型向链表的每一个结点由键盘输入信息，则是不情不愿；还有时候需要复制输出到屏幕的信息……这时候就会想，能不能偷一些懒，毕竟偷懒是个大学问呢，好吧，我在这种偷懒需求之下看了I/O流，下面是我初用文件输入的一个简单代码。 123456789101112131415#include&lt;fstream&gt;int main()&#123; using namespace std; ifstream in_stream; //声明一个文件输入流 ofstream out_stream; //声明一个文件输出流 in_stream.open("infile.txt"); //将输入流连接到文件 out_stream.open("outfile.txt");//将输出流连接到文件 int a, b; in_stream &gt;&gt; a &gt;&gt; b; out_stream &lt;&lt; "a + b = " &lt;&lt; (a+b) &lt;&lt;endl; in_stream.close(); out_stream.close(); return 0;&#125; 在上述代码中，实现的仅仅是将infile.txt文件的前两个数1和1相加的结果放入outfile.txt文件中，注意，这里的outfile.txt是运行代码自动新建的文件，当然了，想要看懂这个代码只需要知道类和对象的基本知识就足够了。这个代码让人感觉到奇怪的地方或许就是in_stream &gt;&gt; ...和out_stream &lt;&lt; ...这两个地方了。按照后面的内容，我们习惯于cin和cout来取代他们。其实你可以理解为cin和cout是进行屏幕输入和输出的流对象，它们的基本作用就是读取和写入字符。还有一个需要说明的地方，预编译指令加载了头文件fstream，是因为文件的输入流类ifstream和输出流类ofstream都包含在该头文件中。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
